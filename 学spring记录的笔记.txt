spring是什么？
spring是一个开源框架，spring是一个IOC(DI)和AOP容器框架
spring是一个容器,因为它包含并且管理应用对象的生命周期
spring是框架,spring实现了使用简单的组件配置组合成一个复杂的应用。在spring中可以使用XML和Java注解组合这些对象

spring jar包的作用:
spring-core-4.0.0.RELEASE.jar 这个jar包包含spring框架基本的核心工具类,spring其他组件都要用到这个包里的类。
spring-context.jar 这个jar包为spring核心提供了大量的扩展。

面试题：什么是JDBC？
JDBC就是用Java语言来操作数据库的一门技术。

接口可以解除耦合关系,什么意思？
没有接口，原来类和类之间是继承的关系,子类要想有父类的方法必须通过继承才能有父类的方法，但是有了接口之后就可以在接口
中定义方法,然后实现这个接口,类和类之间的关系就解开了。

工厂方法设计模式:定义一个用于创建对象的接口,让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。
public class FactoryMethod {
	public static void main(String[] args) {
		IWorkFactory i1 = new StudentWorkFactory();
		i1.getWork().doWork();
		IWorkFactory i2 = new TeacherWorkFactory();
		i2.getWork().doWork();
	}
}

interface IWorkFactory{
	Work getWork();
}

class StudentWorkFactory implements IWorkFactory{

	@Override
	public Work getWork() {
		return new StudentWork();
	}
}

class TeacherWorkFactory implements IWorkFactory{

	@Override
	public Work getWork() {
		return new TeacherWork();
	}
}

interface Work{
	void doWork();
}

class StudentWork implements Work{

	@Override
	public void doWork() {
		System.out.println("学生写作业");
	}
}
class TeacherWork implements Work{

	@Override
	public void doWork() {
		System.out.println("老师批改作业");
	}
}

代理模式:为其他对象提供一种代理以控制对这个对象的访问。
代理模式的一个好处就是对外部提供统一的接口方法，而代理类在接口中实现对真实类的附加操作行为，从而可以在不影响外部调用
情况下，进行系统扩展。也就是说，我要修改真实角色的操作的时候，尽量不要修改他，而是在外部在“包”一层进行附加行为，即
代理类。例如：接口A有一个接口方法operator()，真实角色：RealA实现接口A，则必须实现接口方法operator()。客户端Client
调用接口A的接方法operator()。现在新需求来了，需要修改RealA中的operator()的操作行为。怎么办呢？如果修改RealA就会影响
原有系统的稳定性，还要重新测试。这是就需要代理类实现附加行为操作。创建代理ProxyA实现接口A，并将真实对象RealA注入进来
。ProxyA实现接口方法operator()，另外还可以增加附加行为，然后调用真实对象的operator()。从而达到了“对修改关闭，对扩展
开放”，保证了系统的稳定性。我们看客户端Client调用仍是接口A的接口方法operator()，只不过实例变为了ProxyA类了而已。也
就是说代理模式实现了ocp原则。
静态代理
public class Proxy {
	public static void main(String[] args) {
		Object o = new ProxyObject();
		o.action();
	}
}

interface Object{
	void action();
}

class ProxyObject implements Object{
	Object obj;
	public void action() {
		System.out.println("代理类开始执行");
		obj.action();
		System.out.println("代理方法执行完毕");
	}
	public ProxyObject() {
		System.out.println("代理方法创建成功");
		obj = new ObjectImp();
	}
	
}
class ObjectImp implements Object{
	public void action() {
		System.out.println("=====被代理类======");
		System.out.println("=====被代理类的操作==");
	}
}
利用反射可以实现动态代理

静态代码块随着类的加载而加载，而且只被加载一次。
非静态代码块是随着对象的加载而加载，在构造器之前加载。

反射：
反射允许程序在执行期间借助ReflectionAPI取得任何类的内部信息，并能直接操作对象的内部属性及方法。
反射相关的API:
java.lang.Class 代表一个类
java.lang.reflect.Method 代表类的方法
java.lang.reflect.Field 代表类的成员变量
java.lang.reflect.Constructor 代表类的构造方法
通过反射调用对象的属性和方法:
		Class<Person> clazz = Person.class;
		Person p1 = clazz.newInstance();//创建运行时类的对象
		下面的这行代码我想去调用Person里面的name属性(name属性是私有的，也可以通过反射去调用)
		Field f1 = clazz.getDeclaredField("name");	person里面有一个属性叫name 通过clazz.getDeclaredField("name")去拿到这个属性,因为name声明成了private,所有要加Declared,如果name是public的就可以直接getField()
		f1.setAccessible(true);	因为name是私有的所以要加这句代码让他可以访问，否则会报访问权限异常。
		f1.set(p1, "zhangsan");	p1就是那个运行时类的对象,这句代码就是说设置p1这个运行时类的对象的name属性为zhangsan
		System.out.println(p1);
		
		Method m1 = clazz.getMethod("show");调属性用getField()调方法就用getMethod()
		m1.invoke(p1);  属性是用set去设置属性的值，而方法则是直接调invoke()方法去执行方法。p1是哪一个对象，有的方法需要传入参数,就在后面写。
		
		Method m2 = clazz.getMethod("display", String.class);第一个参数是方法名，第二个参数是这个方法传入参数的类型。
		m2.invoke(p1, "China");
		
java.lang.Class:是反射的源头
我们创建一个类是通过编译(javac.exe)，生成对应的.class文件。之后我们使用java.exe加载(JVM的类加载器)此.class文件
此.class文件加载到内存以后就是一个运行时类,存在缓存区。那么这个运行时类本身就是一个Class！

有了Class实例之后，可以进行如下操作：
1).创建对应的运行时类的对象
2).可以获取到对应的运行时类的完整结构(属性、方法、构造器、内部类、父类、所在的包、异常、注解等)
3).调用对应的运行时类的指定结构

如何去获取Class的实例：(3种)
1.调用运行时类本身的.class属性
Class clazz = Person.class;
System.out.println(clazz);

2.通过运行时类的对象获取
Person p = new Person();
Class clazz2 = p.getClass();
System.out.println(clazz2);
3.通过Class的静态方法获取
String className = "com.iflytek.factory.test.Person";
Class clazz = Class.forName(className);
Person p = (Person) clazz.newInstance();
System.out.println(p);

有了Class实例能做什么？
1.创建类的对象：调用Class对象的newInstance()方法
newInstance()方法默认调用类的无参构造器，如果类没有无参构造器，则报初始化错误

Class实例获取运行时类的属性:
Class clazz = Person.class;
Field[] fields = clazz.getFields();			getFields()方法只能获取到声明为public修饰符的属性  (可以获取到运行时类及其父类声明为public的属性)
for(int i = 0;i<fields.length;i++){
	System.out.println(fields[i]);
}
要想获取到所有的属性,必须使用getDeclaredFields();    (只能获取运行时类的本身属性)
Field[] declaredFields = clazz.getDeclaredFields();
for(Field f :declaredFields){
	System.out.println(f.getName());
}

Class实例获取运行时类的方法：
Class clazz = Person.class;
Method[] methods = clazz.getMethods();  getMethods()方法可以获取修饰符为public的直接或间接父类的方法和本身修饰符public的方法
for(Method m :methods){
	System.out.println(m);
}
要想获取到本身类的所有方法，需使用clazz.getDeclaredMethods()
Method[] declaredMethods = clazz.getDeclaredMethods();
		for(Method m1 :declaredMethods){
			System.out.print(m1);
		}
		
**********************************************必须会************************************************************
调用运行时类的指定属性：
Class clazz = Person.class;
//获取指定的属性
Field name = clazz.getField("name");
Person p = (Person) clazz.newInstance();	创建运行时类的对象
name.set(p, "Jimmy");
System.out.println(p);

Field age = clazz.getDeclaredField("age");	这里的age属性是private的所以要用getDeclaredField
age.setAccessible(true);										还要设置它的访问权限是true
age.set(p, 12);
System.out.println(p);

调用运行时类中指定的方法:
Class clazz = Person.class;
Person p = (Person) clazz.newInstance();
Method m = clazz.getMethod("show", null);				如果调用声明为private的方法就要用getDeclaredMethod()
m.invoke(p, null);
Method m1 = clazz.getMethod("display", String.class);
m1.invoke(p, "美国");		这个invoke方法是有返回值的，

Method m2 = clazz.getMethod("toString", null);
java.lang.Object returnVal = m2.invoke(p, null);
System.out.println(returnVal);

调用运行时类中指定的构造器:
String className = "com.iflytek.factory.test.Person";
Class clazz = Class.forName(className);
Constructor con = clazz.getDeclaredConstructor(String.class,int.class);
con.setAccessible(true);
Person p = (Person)con.newInstance("Jimmy",41);		newInstance方法也是有返回值的
System.out.println(p);
**********************************************必须会************************************************************

java动态代理:
动态代理是指客户通过代理类来调用其他对象的方法，并且在程序运行时根据需要动态创建目标类的代理对象
interface Subject{
	void action();
}
//被代理类
class RealSubject implements Subject{
	@Override
	public void action() {
		System.out.println("我是一个代理类");
	}
}
//凡是和动态代理相关的都要用到InvocationHandler这样一个接口
class MyInvocationHandler implements InvocationHandler{
	java.lang.Object obj;
	//下面的这个blind方法有两个作用,1.给被代理的对象实例化 2.返回一个代理对象
	public java.lang.Object blind(java.lang.Object obj){
		this.obj = obj;
		//既然被代理类实现了接口并重写了抽象方法,那么代理类也要重写这个抽象方法
		//最后一个参数就是实现了InvocationHandler这个接口的类对象
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(), this);
	}
	//当代理类对象调用重写方法的时候,都会自动转为对invoke方法的调用。
	@Override
	public java.lang.Object invoke(java.lang.Object proxy, Method method,
			java.lang.Object[] args) throws Throwable {
		Object returnVal = method.invoke(obj, args);
		return returnVal;
	}
	
}
public class TestProxy {
	public static void main(String[] args) {
		//首先创建被代理类的对象
		RealSubject rs = new RealSubject();
		MyInvocationHandler mih = new MyInvocationHandler();
		java.lang.Object obj = mih.blind(rs);
		Subject sub = (Subject) obj;
		sub.action();
	}
}	  


动态代理与AOP:
interface Human{
	void info();
	void fly();
}
//接口的实现类,被代理类。
class SuperMan implements Human{
	public void info() {
		System.out.println("我是超人");
	}
	public void fly() {
		System.out.println("我可以飞的更高");
	}
}
class HunmanUtil{
	public void method1(){
		System.out.println("*********方法一**********");
	}
	public void method2(){
		System.out.println("*********方法二**********");
	}
}
//要想实现动态代理的创建,设计到两个东西,InvocationHandler的实现类,还有一个Proxy代理类实例的创建
class MyInvocationHandler implements InvocationHandler{
	Object obj;	//被代理对象的声明
	public void setObject(Object obj){	//这个方法就是实例化被代理对象
		this.obj = obj;
	}
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		HunmanUtil h = new HunmanUtil();
		h.method1();
		Object returnVal = method.invoke(obj, args);//在两个写死的方法中间插入(中间这个方法时动态的)
		h.method2();
		return returnVal;
	}
}
class MyProxy{
	//动态的创建一个代理类的对象
	//要想创建一个代理类的对象,我要知道被代理类是什么,所以传入一个被代理类的参数,obj就是被代理类对象
	public static Object getProxyInstance(Object obj){
		MyInvocationHandler handler = new MyInvocationHandler();
		handler.setObject(obj);
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);
		//上面一行代码就是返回一个代理类的对象
	}
}
public class TestAOP {
	public static void main(String[] args) {
		SuperMan superMan = new SuperMan();
		Object obj = MyProxy.getProxyInstance(superMan);//这行代码返回的是一个代理类的对象
		Human h = (Human) obj;
		h.fly();
	}
}
	
		
包装类(Wrapper)：
针对8种基本数据类型定义的引用类型--包装类
包装类主要掌握，基本数据类型和包装类和String三者之间的转换。

基本数据类型和包装类之间的转换：
int i = 10;
Integer i1 = new Integer(i);
System.out.println(i1);
														方法：调用包装类的构造器
Float f = new Float(23.1f);
System.out.println(f);  
包装类转化为基本的数据类型：
int i2 = i1.intValue();
System.out.println(i2);			方法:调用xxxvalue方法
float f2 = f.floatValue();
System.out.println(f2);

JDK5.0以后，自动装箱拆箱。以为着上面的就不用了
Integer i = 12;（自动装箱）				左边是一个包装类，是一个类，右边是一个基本数据类型
int i1 = i; （自动拆箱）i是Integer这个包装类的对象，将i直接赋值给i1这个基本数据类型
 
基本数据类型、包装类转化为String:调用String的valueOf方法
int i = 10;
String str = String.valueOf(i);
System.out.println(str.getClass());

String 转化为基本数据类型、包装类：调用包装类.parsexxx方法 
int i1 = Integer.parseInt(str);
System.out.println(i1);


接口：
接口里面只能有常量和抽象方法，常量默认是public static final 修饰的，抽象方法默认是public abstract修饰的
接口和接口之间是继承关系，而且可以实现多继承。

枚举类：
什么是枚举类，根据字面意思就是你这个类里面的对象是有限个的可以给你枚举出来，对象是有限个的，如果只有一个，那就是单例。
若枚举只有一个成员，则可以作为一种单例模式的实现。
自定义枚举类
class Season{
	private final String seasonName;
	private final String seasonDesc;
	//私有化构造器，外部调不了。上面声明的属性在构造器中初始化，一旦初始化不能被修改
	private Season(String seasonName,String seasonDesc) {
		this.seasonName = seasonName;
		this.seasonDesc = seasonDesc;
	}
	public String getSeasonName() {
		return seasonName;
	}
	public String getSeasonDesc() {
		return seasonDesc;
	}
	public static final Season SPRING = new Season("春天", "春暖花开"); 
	public static final Season AUTUMN = new Season("秋天", "好多落叶"); 
	public static final Season SUMMEWR = new Season("夏天", "太阳"); 
	public static final Season WINTER = new Season("冬天", "大雪纷飞"); 
	@Override
	public String toString() {
		return "Season [seasonName=" + seasonName + ", seasonDesc="
				+ seasonDesc + "]";
	}
	public void show(){
		System.out.println("这是一个季节");
	}
}

如何使用enum关键字定义枚举类
enum Season1{
	SPRING("春天", "开花"),			这四个都是对象 SPRING SUMMER AUTUMN WINTER
	SUMMER("夏天", "太阳"),
	AUTUMN("秋天", "落叶"),
	WINTER("冬天", "大雪");
	private final String seasonName;
	private final String seasonDesc;
	private Season1(String seasonName,String seasonDesc) {
		this.seasonName = seasonName;
		this.seasonDesc = seasonDesc;
	}
	public String getSeasonName() {
		return seasonName;
	}
	public String getSeasonDesc() {
		return seasonDesc;
	}
	@Override
	public String toString() {
		return "Season1 [seasonName=" + seasonName + ", seasonDesc="
				+ seasonDesc + "]";
	}
	}
用enum定义的枚举类Season1下面有一个方法.values(),这个方法可以将枚举类下面的所有对象以一个数组的形式返回
public static void main(String[] args) {
		Season1 spring = Season1.SPRING;
		System.out.println(spring);
		System.out.println(spring.getSeasonName());
		Season1[] values = Season1.values();
		for(Season1 val : values){
			System.out.println(val);
		}
	}
让枚举类实现接口:
枚举类实现接口后要重写这个接口的抽象方法，然后你可以通过枚举类的对象来调这个重写的抽象方法，但是你不管通过哪一个枚举类对象调用
这个方法，执行效果都一样，要是想不同的枚举类对象调这个方法会有不同的效果就要在这个里面重写接口的抽象方法
	SPRING("春天", "开花"){
		public void show(){
			System.out.println("春天好");
		}
	},
	SUMMER("夏天", "太阳"){
		public void show(){
			System.out.println("夏天好");
		}
	},
	AUTUMN("秋天", "落叶"){
		public void show(){
			System.out.println("秋天好");
		}
	},
	WINTER("冬天", "大雪"){
		public void show(){
			System.out.println("冬天好");
		}
	};

	
StringBuffer 和 StringBuider:
java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。
StringBuffer（JDK1.0的时候就有了）的方法：
append()	在后面追加
insert(int index,String str)	在指定位置插入一个字符串
reverse() 反转此StringBuffer
replace(int startIndex,int endIndex,String str)	替换
delete(int startIndex,int endIndex)	删除
String substring(int start,int end)	截取字符串

StringBuider：JDK1.5之后新增的
涉及到线程安全问题的话，StringBuider线程不安全。但是如果不考虑线程安全问题的话，StringBuider的执行效率要比StringBuffer高


日期类:
Date类
Date date = new Date();
System.out.println(date);
System.out.println(date.getTime());//1462084125348 获取时间戳long型
Date date2 = new Date(1462084125348L);	//将时间戳变为Date类型
System.out.println(date2);

SimpleDateFormat类:
SimpleDateFormat sdf = new SimpleDateFormat();
String str = sdf.format(new Date());
System.out.println(str); 	//默认的16-5-1 下午3:13

SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm");
str = sdf1.format(new Date());
System.out.println(str);	//2016-05-01 03:13

//返回date1和date2之间的天数
public int getDays(String date1,String date2) throws ParseException{
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
	Date d1 = sdf.parse(date1);
	Date d2 = sdf.parse(date2);
	long time = d2.getTime()-d1.getTime();
	return (int)(time/1000/3600/24+1);			传入的date1和date2均为String类型的字符串通过sdf.parse(date1)将字符串解析为Date类型
}		


Filter过滤器:
Filter的基本功能是对Servlet容器调用Servlet的过程进行拦截,从而在Servlet进行响应处理的前后实现一些特殊的功能。
在Servlet API中定义了三个接口类来供开发人员编写Filter程序:Filter FilterChain FilterConfig

Filter是什么？
Filter是一个实现了Filter接口的Java类,可以对发送到Servlet的请求进行拦截，并对响应也可以进行拦截。
Filter对象是在Servlet容器加载当前web应用的时候就被创建

public void init(FilterConfig arg0) throws ServletException {
		//init方法在创建Filter对象后就立即被调用,且只被调用一次
		该方法主要用于对当前Filter进行初始化操作
}
public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
			真正Filter的逻辑代码需要编写在该方法中,每次拦截都会调用该方法。
			FilterChain: filter链,多个Filter可以构成一个Filter链
			chain.doFilter(request, response);  把请求传给Filter链的下一个Filter,若当前的Filter是Filter链的最后一个Filter
			则把请求传给目标资源（Servlet或者jsp）。
			多个Filter的拦截顺序和<filter-mapping>配置顺序有关，配置靠前的先被调用。
			上面那句话另一种表述方式:Filter链中各个Filter的拦截顺序与他们在应用程序的web.xml中映射的顺序一致。
}
public void destroy() {
	在Filter销毁之前被调用,且只被调用一次。
}

<filter-mapping>里面的<dispatcher>指定过滤器所拦截的资源被Servlet容器所调用的方式
如果<dispatcher>的子元素是REQUEST(默认是REQUEST)当用户直接访问页面时，web容器会调用过滤器。如果目标资源是通过转发的方式访问页面，那么过滤器不会被调用。
如果<dispatcher>的子元素是FORWARD那么目标资源如果哦是通过转发的方式来访问页面那么过滤器将被调用。 


监听器:
专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时立即采取行动。
servlet监听器：用于监听web应用程序中的ServletContext,HttpSession和ServletRequest等域对象的创建和销毁事件，以及监听这些域对象中属性发生修改的事件。

按监听事件类型Servlet监听器可分为如下三种类型：
---监听域对象自身创建和销毁的事件监听器
---监听域对象中属性的增加和删除的事件监听器
---监听绑定到HttpSession域中某个对象的状态的事件监听器

下面来说说第一种监听域对象自身创建和销毁的事件监听器,以ServletContext为例：
我们都知道ServletContext这个域对象是在当前WEB应用被加载的时候创建当前WEB应用被卸载的时候销毁。
你现在要写的是监听域对象创建和销毁事件的监听器,那么你就要去实现ServletContextListener这个接口。然后重写
这个接口里面的抽象方法。假如我要监听HttpSession这个对象的创建和销毁,那么我就要去实现HttpSessionListener这个接口。
还是以ServletContext为例,代码说明：
public class HelloServletContext implements ServletContextListener {
	public void contextDestroyed(ServletContextEvent sce) {      这个参数的作用就是,我可以通过这个参数来获取ServletContext,使用sce.getServletContext()
		System.out.println("ServletContext对象被销毁");
	}

	public void contextInitialized(ServletContextEvent sce) {
		System.out.println("ServletContext对象被创建");
	}
}
除了上面的代码以外,我还要在web.xml中配置一下:
<listener>
		<listener-class>com.iflytek.listener.test.HelloServletContext</listener-class>
</listener>
这样写完以后,当我项目一启动的时候,控制台就会打印"ServletContext对象被创建",当我项目一停止就会打印
"ServletContext对象被销毁"。
其实准确的说应该是当前WEB应用被加载的时候打印"ServletContext对象被创建",当前WEB应用被卸载的时候打印"ServletContext对象被销毁"
当前WEB应用被加载和卸载与项目启动和停止还是有区别的,比如说你把上面写的Servlet的内容在项目运行的
时候随便改一下,那么eclipse就会自动帮你编译,卸载修改前的WEB应用并重新加载修改后的WEB应用。即这时候
控制台就会打印"ServletContext对象被销毁"和"ServletContext对象被创建"。而我的项目并没有手动的去
停止再重启。

我们说ServletContextListener是最常用的一个Listener,要是实现了这个接口我就可以对ServletContext这个
域对象进行监听,当前WEB应用被加载的时候就会调contextInitialized(ServletContextEvent sce)这个方法,
所以我就可以对相关资源进行初始化操作。








域对象的创建和销毁的事件监听器就是用来监听ServletContext,HttpSession和ServletRequest这三个对象的创建和销毁事件的监听器。
ServletContext创建时机:web服务器启动时为每个web应用程序创建相应的ServletContext对象
ServletContext销毁时机:web服务器关闭时为每个web应用程序销毁相应的ServletContext对象
HttpSession创建时机:浏览器开始与服务器会话时创建
HttpSession销毁时机：调用HttpSession.invalidate();超过了Session的最大有效时间间隔;服务器的进程被停止。
ServletRequest创建时机：每次请求的时候开始创建。
ServletRequest销毁时机：每次访问结束后销毁。

ServletContextListener:
监听ServletContext对象被创建或销毁的Servlet监听器
ServletContextListener是最常用的Listener,可以在当前web应用被加载的时候对当前web应用的相关资源进行初始化操作：
创建数据库连接池，创建Spring的IOC容器，读取当前web应用的初始化参数。
ServletContext对象什么时候被创建？当前web应用被加载的时候

request发送请求的时候被创建，请求结束的时候被销毁。比如说你在A页面写了一个<%requset.setAttribute("requestKey","requestValue")  %>
和<a href = "B"><a/>你点击超链接去B页面通过getAttribute去拿，这时候拿不到，因为你点击超链接又是一个请求，两个请求不一样自然拿不到
但是如果你在A页面通过转发的方式去B页面拿，那么就可以拿的到，因为转发是同一个请求。

session:当第一次访问web应用的一个jsp或者Servlet的时候，且该jsp或者Servlet还需要创建session的时候创建session对象
关闭浏览器，并不意味着session被销毁，还可以通过sessionId找到服务器中的session对象
******************************************************************************************************************

																										springMVC部分

******************************************************************************************************************
RESTful风格的SpringMVC CRUD

springMVC的form标签：可以更快速的开发页面，可以进行表单值回显。
报这个错误 Neither BindingResult nor plain target object for bean name 'command' available as request attribute
使用了form标签，你想来显示这个页面就是让页面正常显示，必须在域对象中有这个bean,这个bean有跟表单path对应的属性
可以通过modelAttribute属性指定绑定的模型属性，如果没有该属性，则默认从request域对象中读取command的表单bean,如果该属性值也不存在则会报错。
springmvc认为表单值一定是要进行回显的

springNVC静态资源问题：
为什么会有这样的问题？因为优雅的REST风格的资源的URL不希望带.html和.do等后缀。若将DispatcherServlet的请求映射配置为/，
则springMVC将捕获WEB容器的所有请求，包括静态资源（图片、js、css）请求。SpringMVC会把他们当成一个普通的请求处理（因为它们没有被映射）
所有找不到对应的处理器而出错。
解决办法：在spring的配置文件中写上<mvc:default-servlet-handler/>
写上它的作用就是default-servlet-handler将在springMVC上下文定义一个DefaultServletHttpRequestHandler,他会对进入DispatcherServlet
的请求进行筛查，如果发现是没有经过映射的请求，将该请求交给web应用服务器默认的Servlet处理。如果不是静态资源请求，才交由
DispatcherServlet处理。


springMVC概述：
springMVC是spring为展现层提供的基于MVC设计理念的优秀web框架，是目前主流的MVC框架之一。
spring3.0以后全面超越Struts2,成为最优秀的MVC框架。
springMVC通过一套MVC注解,让pojo成为处理请求的控制器，而无需实现任何接口。


@RequestMapping：
---DispatcherServlet截获请求后，就通过控制器上的@RequestMapping提供的映射信息确定请求所对应的处理方法。
@RequestMapping(value = "/testParam",params = {"userName","age!=10"})
<a href="testParam?userName=Jimmy&age=11">TestParam</a>
@RequestMapping里有一个参数叫params,他是一个String类型的数组。意思是要求请求的url里必须包含参数userName 和age,并且age的值不能等于10。
@RequestMapping的url支持通配符。   例如：@RequestMapping("/testAntPath/*/abc")


@PathVariable注解：
可以映射URL中的占位符到目标方法的参数中。（正是因为这样的一个特性，才使得Springmvc支持RESTFUL风格的URL）
通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参当中。


REST：
（资源）表现层状态转化。是目前最流行的一种互联网软件架构。

资源：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本，一张图片，一首歌曲，总之就是一个具体的存在。
可以用一个URI指向他，每种资源对应一个URI。要获取这个资源，访问它的uri就可以了，因此URI即为每一个资源的独一无二的标识符。

表现层：把资源具体呈现出来的形式，叫做它的表现层。比如：文本可以用txt格式表现、也可以用HTML格式、XML格式、JSON格式、
甚至可以采用二进制格式。

状态转化：每发出一个请求，就代表客户端和服务器的一次交互过程。HTTP协议，是一个无状态的协议，即所有的状态都保存在服务器
端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生状态转化。而这种转化是建立在表现层之上的，所以就是
“表现层状态转化”。具体的说，就是HTTP协议里面，四个表示操作方式的动词，GET,POST,PUT,DELETE。他们分别对应四种基本操作，
GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。

Rest风格的URL
以CRUD为例：
新增：/order POST
修改：/order/1 PUT	update?id=1
获取: /order/1 GET	get?id=1
删除：/order/1 DELETE		delete?id=1

如何发送PUT请求和DELETE请求？
1.首先需要在web.xml中配置过滤器。
2.然后发送post请求
3.需要在发送post请求的时候携带一个name="_method"的隐藏域，value值为DELETE或PUT


@RequestParam:
例子：
<a href="testRequestParam?userName=Jimmy&age=11">TestRequestParam</a>
@RequestParam(value = "userName")String userName,
@RequestParam(value = "age",required=false,defaultValue="0") int age
可以使用@RequestParam的value属性值来映射来映射那个请求参数。
required:该参数是否必须。
defaultValue：请求参数的默认值。

springMVC会按请求参数名和POJO属性名自动进行匹配。
自动为该对象填充属性值，支持级联属性

----使用servlete原生的api作为入参：
MVC的handler方法里可以接受哪些ServletAPI类型的参数？
HttpServletRequest、HttpServletResponse
HttpSession、Local、
InputStream、OutputStream、
Reader、Writer

public void testServletApI(HttpServletRequest request,
			HttpServletResponse response,Writer writer) throws Exception{
		System.out.println("request:"+request+"response:"+response);
		writer.write("helloSpringMVC");				直接在页面上打出helloSpringMVC
//		return SUCCESS;
	}
	
-----处理模型数据
我们知道MVC设计模式是我们发一个请求到目标处理器，目标处理器去调业务方法，业务方法可能会有返回值，比如说一个对象
或者说是一个集合然后转发到页面，转发到页面时需要把那个返回值（对象或者集合）在页面上显示出来。

springMVC提供了一下几种途径输出模型数据
--ModelAndView
--Map
--@SessionAttributes
--@ModelAttribute

1.ModelAndView
控制器处理方法的返回值如果是ModelAndView，则其既包含视图信息，也包含模型数据信息。
	public ModelAndView testModelAndView(){
		String viewName = SUCCESS;
		ModelAndView modelAndView = new ModelAndView(viewName);
		modelAndView.addObject("time", new Date());
		return modelAndView;
	}
springmvc会把ModelAndView的model数据放到request域对象中

2.Map
目标方法的入参可以加一个Map或者Model类型的参数
public String testMap(Map<String,Object>map){
		map.put("names", Arrays.asList("tom","kelly"));
		return SUCCESS;
	}
	
3.@SessionAttributes
若希望在多个请求之间公用某个模型属性数据，则可以在控制器类上标注一个@SessionAttributes
public String testSessionAttribute(Map<String,Object>map){
		User user = new User("jimmy", "123", "123@qq.com", 12, null);
		map.put("user", user);
		map.put("company", "iflytek");
		return SUCCESS;
	}
除了上面这段代码还要在控制器类上写@SessionAttributes(value = {"user"},types = String.class)
上面的value属性和types属性表示：
@SessionAttributes除了可以通过属性名指定需要放到会话中的属性外（用的就是value属性值）
还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（用的就是types属性）

如果@SessionAttributes(value = {"user"},types = String.class)和map.put("user", user);
@SessionAttributes的value值和map里面的键的值一样，那么map里面的东西就会既放在request域里面也会放在session域里面

4.@ModelAttribute
这个注解的使用场景：现在需要完成一个修改操作，但是修改有一个条件就是有一个字段不能被修改，比如说录入时间就不能修改
假设数据表有三个字段，有一个字段不能被修改。你要修改的话，（页面的form表单传给controller）表单传入的就只能是两个字段，然后在目标方法里有一个对象（controller方法对象作为参数）
这个对象是new的，然后表单把值传过来赋给对象的对应属性，但是只赋了两个属性有一个属性是空。然后拿着这样一个对象
去更新的话显然是有问题的。怎么解决这个问题？
就是form表单传更新参数给controller里的对应对象，但是这个对象不是new的而是从数据库中获取的，这样你
更新两个字段，还有一个字段没更新，但这个字段有值。还是原来从数据库中获取的值。
@ModelAttribute
	public void getUser(@RequestParam("id")Integer id,Map<String,Object> map){
		if(id != null){
			User user = new User(1, "tom", "123", "123@qq.com", 12);
			map.put("user", user);
		}
	}
	@RequestMapping("/testModelAttribute")
	public String testModelAttribute(User user){   这里的user值是新创建的，form表单传过来的参数，有一个password值在form表单没传
		System.out.println("修改:"+user);							所以这里打出来的user值password为空
		return SUCCESS;																
	}
但是加了上面ModelAttribute注解修饰的方法里初始化了一个user，然后放到map里。上面的user会传给下面的user
这样下面的user就有值了，不是新创建的了

注意：在@ModelAttribute修饰的方法中，放入到map时的键需要和目标方法入参类型的第一个字母的小写字符串一致。
如果不一致，报错。

有@ModelAttribute修饰的方法，会在每个目标方法执行之前被springMVC调用。
@ModelAttribute也可以来修饰目标方法POJO类型的入参，其value属性值有如下作用：
1).springMVC会使用value属性值在implicitModel中查找对应的对象，若存在则会直接传到目标方法的入参中。
2).springMVC会以value为key,POJO类型的对象为value,存到request中。
比如说：
map.put("abc", user);
public String testModelAttribute(@ModelAttribute("abc")User user){}   springMVC会使用abc来查找对应的对象，因为上一行map里面有abc，所以直接把map里面的user传进来

sessionattribute引发的一个异常：
org.springframework.web.HttpSessionRequiredException: Session attribute 'user' required - not found in session

	public String testModelAttribute(User user){   
		System.out.println("修改:"+user);						
		return SUCCESS;																
	}
	他先会去implicitModel中去找user对象（没用@ModelAttribute("abc")这个东西修饰，默认就是类名第一个字母小写）
	如果用了这个东西修饰就是去implicitModel找abc这个对象。如果implicitModel里没有的话他会看当前的handler
	是否标识了@SessionAttributes(value = {"user"}),然后看里面的value值是否和User user  一样，如果一样就会
	强制去session里找，找不着就抛异常了。

@SessionAttributes(value = {"user"},types = String.class)
@Controller
public class SpringMVCTest {
	private static final String SUCCESS = "success";
	
//	@ModelAttribute
//	public void getUser(@RequestParam("id")Integer id,Map<String,Object> map){
//		if(id != null){
//			User user = new User(1, "tom", "123", "123@qq.com", 12);
//			map.put("user", user);
//		}
//	}
	@RequestMapping("/testModelAttribute")
	public String testModelAttribute(User user){
		System.out.println("修改:"+user);
		return SUCCESS;
	}
}
上述代码会抛异常，是sessionattribute引发的一个异常。因为它回去session域里面找，没找到就会抛异常。
但是如果把屏蔽的代码打开就不会抛异常。因为map.put("user", user)  user被放到请求域里面
然后@SessionAttributes(value = {"user"},types = String.class)里面的value值和map的键一样,
如果他们俩一样user就会既放在请求域也会放在session域中。   这样去session域里面找就会找到了。

总结描述:若implicitModel中不存在key对应的对象，则检查当前handler是否使用了@SessionAttributes注解修饰
若使用了该注解，且@SessionAttributes注解的value属性值中包含了key,则会从Httpsession中获取key所对应的value值
，若存在，则直接传入到目标方法的入参中，若不存在则抛出异常。
若handler没有标识@SessionAttributes注解或@SessionAttributes注解的value值不包含key,则会通过反射来创建POJO
类型的参数，作为目标方法的参数。


-----可以直接响应转发的页面，而无需经过handler的方法
<mvc:view-controller path="/success" view-name="success"/>
在实际开发中还需要配置下面的注解，不然其他的映射就不好用了。
<mvc:annotation-driven></mvc:annotation-driven>


为什么要加<mvc:annotation-driven></mvc:annotation-driven>这个配置？
<mvc:annotation-driven />会自动注册RequestMappingHandlerMapping、RequestMappingHandlerAdapter
ExceptionHandlerExceptionResolver这三个bean。
还将提供以下支持：
--支持使用ConversionService实例对表单参数进行类型转化。
--支持使用@NumberFormate  @DateTimeFormate注解完成数据类型的格式化。
--支持使用@valid实例对JavaBean实例进行Jsr303验证。
--支持使用@RequestBody @ResponseBody注解

@InitBinder：
由@InitBinder标识的方法，可以对WebDateBinder对象进行初始化。WebDateBinder是DateBinder的子类，用于完成
表单字段到JavaBean属性的绑定。
@InitBinder方法不能有返回值，他必须声明为void
@InitBinder方法的参数通常是WebDateBinder

@InitBinder
public void initBinder(WebDateBinder binder){
		binder.setDisallowedFields("name")					表单到JavaBean赋值的过程中，哪一个值不进行赋值。
}


数据类型转换与格式化：
比如说你现在添加一个用户，这个用户有一个属性是生日。你在添加的时候需要将你写在input框里面的字符串日期
转换为date类型的日期。
方法：首先要配<mvc:annotation-driven/>其次直接在类的属性上加@DateTimeFormate("pattern=yyyy-MM-dd")
比如说：
@DateTimeFormate("pattern=yyyy-MM-dd")
private Date birth


数据校验：
---如何校验？
①使用JSR303验证标准
②加入hibernate validator 验证框架的jar包
③在springMVC配置文件中添加<mvc:annotation-driven/>
④需要在bean的属性上添加相应注解
⑤在目标方法bean类型的前面添加@Valid注解
JSR 303是Java为Bean数据合法性校验提供的标准框架，他已经包含在JavaEE6.0中
JSR 303通过在bean属性上标注类似于@NotNull、@Max等标准的注解指定校验的规则，并通过标准的验证接口对Bean进行验证。

Hibernate Validator是JSR 303的一个参考实现，除支持所有的标准检验的注解外，它还支持以下的扩展注解：
@Email、@Length、@NotEmpth、@Range

SpringMVC数据校验：
Spring4.0拥有自己独立的数据校验框架，同时支持JSR 303标准的校验框架。
Spring本身并没有提供JSR 303的实现，所以必须将JSR 303实现者（Hibernate Validator）的jar包放到类路径下。
Spring的LocalValidatorFactoryBean既实现了Spring的valiator接口，也实现了JSR303的valiator接口，所以只要在
Spring容器中定义一个LocalValidatorFactoryBean，即可将其注入到需要校验的bean中。

怎么去定义或配LocalValidatorFactoryBean？
<mvc:annotation-driven></mvc:annotation-driven>会默认装配好一个LocalValidatorFactoryBean，通过在处理方法
的入参上标注@valid注解即可让SpringMVC在完成数据绑定后执行数据校验工作。

显示错误消息：
在form表单里的每个字段属性的下面加上
<form:errors path="lastName"></form:errors>
简单的说就是在JSP页面上可通过<form:errors path="lastName"></form:errors>显示错误消息

springMVC返回JSON
1、加入jackson相关的jar包
2、目标方法（controller里）直接返回你需要的对象或者集合
@RequestMapping("/testJSON")
@RequestBody
public Collection<Employee>testJSON(){
	return employeeDao.getAll();
}
3、加一个@RequestBody注解
这样我们就可以完成发一个请求然后SpringMVC给我们返回一个json对象或者数组

springMVC返回JSON的背后原理：
其实它是需要HttpMessageConverter这样一个接口。
HttpMessageConverter<T>是Spring3.0新添加的一个接口，负责将请求信息转换为一个对象（类型是T），将对象（类型是T）输出
为响应信息


HttpMessageConverter的工作原理：
														     java对象
											SpringMVC<----------HttpMessageConverter<-------HttpInputMessage<--------请求报文
											SpringMVC---------->HttpMessageConverter------->HttpOutputMessage-------->响应报文
																java对象
你发一个请求先转为HttpInputMessage再由HttpMessageConverter转为SpringMVC需要的对象，对应的SpringMVC返回一个
java对象，它通过HttpMessageConverter转为HttpOutputMessage对象，然后给出响应。
HttpInputMessage：
public interface HttpInputMessage extend HttpMessage{
			InputStream getBody() throws IOException;
}
它返回的是一个输入流，响应的HttpOutputMessage得到的第一个输出流，输出流往外一写不就是响应信息了嘛。

使用HttpMessageConverter：
我们用他干什么？用它把请求信息转化为我们需要的对象传入到目标方法的入参或者把目标方法的返回值转化为
我们想返回给客户的类型返回给客户。
官方一点的说法：使用HttpMessageConverter将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型
的响应信息。
@RequestBody用来修饰目标方法的入参的。@ResponseBod用来修饰目标方法的。
例：
public String testHttpMessageConverter(@RequestBody String body){
				比如说这个目标方法的入参使用了@RequestBody来修饰，这个参数是一个String类型
				它就会把请求信息转化为String类型的字符串传到目标方法
}


关于国际化：
1、在页面上能够根据浏览器语言设置的情况对文本、时间、数值进行本地化处理
2、可以在bean中获取国际化资源文件Locale对应的消息。
3、可以通过超链接切换Locale，而不再依赖浏览器的语言设置情况。
解决：
1、使用JSTL的fmt标签

文件上传：
springMVC为文件上传提供了直接的支持，这种支持是通过即插即用的MultipartResolver（他其实是一个接口）实现的。
spring用Jakarta Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。
springMVC的上下文默认没有装配MultipartResolver，因此默认情况下不能处理文件的上传工作，如果想使用spring的文件
上传功能，需先在上下文配置MultipartResolver。
在springMVC的配置文件中配置MultipartResolver：
<bean id="commonsMultipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<property name="defaultEncoding" value="UTF-8"></property>
		<property name="maxUploadSize" value="1024000"></property>
</bean>


拦截器：
首先想搞一个自定义的拦截器，需要先建一个类，然后实现HandlerInterceptor接口。重写里面的抽象方法
例：public class FirstInterceptor implements HandlerInterceptor{
				public void afterCompletion(HttpServletRequest arg0,
													HttpServletResponse arg1, Object arg2, Exception arg3)throws Exception {
										渲染视图之后被调用（在DispatcherServlet完全处理完请求后被调用）		
										可以在该方法中进行一些资源清理的操作
			}
			
			public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1,
														Object arg2, ModelAndView arg3) throws Exception {
										调用目标方法之后（业务处理器处理完请求之后）
										渲染视图之前被调用	（DispatcherServlet向客户端返回响应之前被调用）
			}
			
			public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1,
															Object arg2) throws Exception {
							该方法在目标方法之前被调用。
							若返回值为true,则继续调用后续的拦截器和目标方法
							若返回值为false,则不会调用后续的拦截器和目标方法。
							return true;
			}
}
然后还需要在springMVC的配置文件中配置一下
<mvc:interceptors>
		<bean class="com.iflytek.springmvc.intercept.FirstInterceptor"></bean>配置bean节点
</mvc:interceptors>

如果某一个拦截器的的preHandle方法返回一个false,那么后面的拦截器就不会被调用，而且目标方法也不会被调用。

知道了这三个方法的调用顺序，这三个方法具体有什么用呢？
----preHandle：
它在调目标方法之前被调用，可以考虑做权限（如果你没有权限就不让你调用目标方法）或者是日志、事务等

----postHandle
可以对请求域中的属性或视图做出修改。

----afterCompletion
可以做释放资源使用

<mvc:interceptors>
		<bean class="com.iflytek.springmvc.intercept.FirstInterceptor"></bean>
		<!-- 配置拦截器(不)作用的路径 -->
		<mvc:interceptor>
			<mvc:mapping path="/testParam"/>
			<bean class="com.iflytek.springmvc.intercept.SecondInterceptor"></bean>
		</mvc:interceptor>
</mvc:interceptors>
在<mvc:interceptors>里面可以在配一个<mvc:interceptor>指定拦截器作用于哪些路径和不作用于哪些路径
像上面的这个例子就是FirstInterceptor这个拦截器作用于所有的，而SecondInterceptor这个拦截器只作用于
testParam这个路径的请求。

多个拦截器的执行顺序：
对于preHandle按springMVC配置文件中配置的顺序执行，
对于postHandle按springMVC配置文件中配置的反序执行，
对于afterCompletion按springMVC配置文件中配置的反序执行。

FirstInterceptor#preHandle------->SecondInterceptor#preHandle
																					↓
																					↓
																					↓
																  HandlerAdapter#handle(目标方法)
																  				↓
																					↓
																					↓
FirstInterceptor#postHandle←←←←←←SecondInterceptor#postHandle
						↓
						↓→→→→→→→→→→→→DispatcherServlet#render(渲染视图)
																					↓
																					↓
																					↓
FirstInterceptor#afterCompletion←←←←←←SecondInterceptor#afterCompletion

如果一个拦截器没有任何问题执行完了，那么是一定执行释放资源的这个afterCompletion方法。
如果某一个拦截器的preHandle方法已经返回false了，
我就不需要去释放资源了就不需要执行这个拦截器的afterCompletion方法了


异常处理：
springMVC通过HandlerExceptionResolver处理程序的异常，包括Handler映射、数据绑定以及目标方法执行时发生的
异常。
DispatcherServlet默认装配的HandlerExceptionResolver：
①ExceptionHandlerExceptionResolver
②ReponseStatusExceptionResolver
③DefaultHandlerExceptionResolver

ExceptionHandlerExceptionResolver：
主要处理Handler中用ExceptionHandler注解定义的方法。

写了一个可能发生算数异常的方法：
@RequestMapping("/testExceptionHandlerExceptionResolver")
	public String testExceptionHandlerExceptionResolver(@RequestParam("i") int i){
		System.out.println("result:"+10/i);
		return SUCCESS;
}
如果传入的i=0那么就会发生算数异常，接下来就去处理这个异常。
@ExceptionHandler({ArithmeticException.class})							使用@ExceptionHandler注解，里面是异常类型的数组
public ModelAndView testArithmeticException(Exception e){
		System.out.println(e);
		ModelAndView mv = new ModelAndView("error");
		mv.addObject("Exception", e);
		return mv;
}
注：@ExceptionHandler标记的方法的入参中可以加入Exception类型的参数，该参数即对应发生的异常对象。
@ExceptionHandler标记的方法的入参中不能传入Map,若希望把异常信息传到页面上，需要使用ModelAndView作为返回值

@ExceptionHandler只能处理当前handler方法里面抛得异常，而不是一个更全局的。
要想搞全局的：
@ControllerAdvice
public class HandleException {
	@ExceptionHandler({ArithmeticException.class})
	public ModelAndView testArithmeticException(Exception e){
		System.out.println("--->"+e);
		ModelAndView mv = new ModelAndView("error");
		mv.addObject("Exception", e);
		return mv;
	}
}
直接把上面的代码写到一个类里面去，类的上面用@ControllerAdvice注解标记

@ControllerAdvice：如果在当前handler中找不到@ExceptionHandler标记的方法来来处理当前方法出现的异常 
则将去@ControllerAdvice标记的类中查找@ExceptionHandler标记的方法来处理异常。


springMVC运行流程：
首先是发一个请求过来，然后我们要看这个请求能不能发给我们在web.xml中配置的DispatcherServlet,
假如说能发过来，那么我的这个请求应该和DispatcherServlet的那个url-pattern向对应。
然后要看在springMVC里面有没有对应的映射（就是我有没有用那个RequestMapping映射过），如果要是没有映射过
还要来看有没有配置过<mvc:default-servlet-handler/>，如果这个也没有配置的话，控制台会有一个打印，说没有对应的
映射。（No mapping found for HTTP request with URI[/xx/xx] in DispatcherServlet ）同时给一个404页面。
如果有配置<mvc:default-servlet-handler/>，就会去找目标资源。（目标资源如果没有的话也会404但是控制台不会打印没有对应的映射这个消息）


需要进行spring整合springMVC吗？
1、需要。通常情况下类似于数据源、事务，整合其他框架都是放在spring的配置和文件中而不是放在springMVC的配置文件中。
2、不需要。都放在springMVC的配置文件中。（在web.xml文件中写springMVC的配置文件的路径的时候可以写通配符）

若spring的IOC容器和springMVC的IOC容器扫描的包有重合的部分，就会导致bean被创建2次。
解决创建2次:
使用<context:component-scan base-package="com.iflytek.springmvc" use-default-filters="false">
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
使用include-filter来规定只能扫描的注释





******************************************Mybatis学习*******************************************************
mybatis是支持普通SQL查询、存储过程和高级映射的优秀持久层框架。
dbutils可以自动封装查询结果集。

现在有个需求，就是根据id查到user对象。

1、首先我需要在userMapper.xml文件中写sql语句
<mapper namespace="com.iflytek.mybatic.test1.userMapper">  	namespace用来标识这个xml文件（使用包名+文件名不要后缀）这个xml所在的包和这个xml的文件名
		<select id="getUser" parameterType="int" resultType="com.iflytek.mybatic.test1.Users">
					select * from users where id = #{id}
		</select>
</mapper>
2、写好之后我需要把映射文件注册到mybatis的配置文件中
<configuration>
	<environments default="development">
		<environment id="development">
			<transactionManager type="JDBC" />
			<dataSource type="POOLED">
				<property name="driver" value="${driver}" />
				<property name="url" value="${url}" />
				<property name="username" value="${name}" />
				<property name="password" value="${password}" />
			</dataSource>
		</environment>
	</environments>
	<mappers>
		<mapper resource="/com/iflytek/mybatic/test1/userMapper.xml"/>
	</mappers>
</configuration>

小知识：src下面的资源我要去加载它，可以使用类加载器。
3、写个main方法测试跑一下
	public static void main(String[] args) {
		InputStream inputStream = Test.class.getClassLoader().getResourceAsStream("conf.xml");
		SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);
		SqlSession sqlSession = factory.openSession();
		String statement = "com.iflytek.mybatic.test1.userMapper.getUser";
		Users user = sqlSession.selectOne(statement, 1);
		System.out.println(user);
	}
	

*Mapper.xml里面一些基本的增删改查：
<insert id="addUser" parameterType="com.iflytek.mybatic.test1.Users">
		insert into users(name,age) values(#{name},#{age})      注意：#{}里面的名字一定要写user里面的属性，因为你传入的参数类型是user,所以他插入的时候（执行这句代码的时候）会根据你传入的user里面的各个属性值来匹配数据库里面的字段
</insert>

<delete id="deleteUser" parameterType="int">
		delete from users where id=#{id}				注：#{}	这里面的id可以随便写，因为它传进来的参数就一个。
</delete>

<update id="updateUser" parameterType="com.iflytek.mybatic.test1.Users">
		update users SET name = #{name},age = #{age} WHERE id = #{id}
</update>

<select id="getUser" parameterType="int" resultType="com.iflytek.mybatic.test1.Users">
		select * from users where id = #{id}			结果类型：是一个user，所以要写这个user的全类名
</select>

测试类,测试上面的方法：
public void testInsert(){
		SqlSession sqlSession = MybatisUtils.getSqlSession();
		String statement = "com.iflytek.mybatic.test2.userMapper.addUser";
		Users user = new Users("kimi", 12);
		int insert = sqlSession.insert(statement, user);
		//sqlSession.commit();					如果我把这行注释掉，程序跑的没有问题。但是就是没有插入到数据库中
		System.out.println(insert);			因为它默认是手动提交的，即需要加上注释的这句话。不然数据库里面是没有数据的
}

public class MybatisUtils {
	public static SqlSession getSqlSession(){
		InputStream inputStream = MybatisUtils.class.getClassLoader()
				.getResourceAsStream("conf.xml");
		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder()
				.build(inputStream);
		SqlSession sqlSession = sessionFactory.openSession();		这里开session的时候默认是手动提交事务的
		return sqlSession;																	如果需要他自动提交，可以调他的重载方法  .openSession(true)
	}																											这样就不需要写上面那行注释的代码了，它就会自动提交事务
}

注：添加、修改、删除都要提交事务。添加---你添加一条记录到数据库，如果不提交事务你在数据库里面是看不见添加的数据的
																	修改---你修改一条记录，如果修改完后不提交事务，你发现数据库里面还是原来数据根本没修改，要提交事务才能修改
																	删除---你删除一条记录，删除后提交事务，刷新数据库才能删除，要是没提交事务，你删除了，但数据库里面的数据还在。
																	查询---不用提交事务，直接从数据里查就好了
																	

说明：
每次resultType参数的值写全类名太麻烦，可以在配置文件里面给他起一个别名
<typeAliases>
		<typeAlias type="com/iflytek/mybatic/test1/Users.java" alias="User"/>
</typeAliases>				下次就可以直接写User了

或者使用：
<typeAliases>
		<package name="com.iflytek.mybatic"/>	给这个包下面取别名		比如说user这个类，别名就是这个类的简单类名。
</typeAliases>


字段名与实体类属性名不相同问题：
<select id="getOrder" parameterType="int" resultType="com.iflytek.mybatic.bean.Order">
		select order_id id,order_no orderNum,order_price price from order where order_id=#{id}
</select>
主要是它在找的时候，order_id=#{id}是根据数据库的字段名称去匹配类里面的属性，所以你要让他匹配上给数据库字段起个别名
别名和类的属性名一样他就能匹配到了。

mybatis的处理方式：
上面的方法是我们自己的处理方式。
<select id="getOrder" parameterType="int" resultMap="getOrderMap">这个getOrderMap需要和下面的id值一样，时引用他的。
		select *from order where order_id=#{id}
	</select>
	<resultMap type="Order" id="getOrderMap">
		<id column="order_id" property="id"/>
		<result column="order_no" property="orderNum"/>
		<result column="order_price" property="price"/>
</resultMap>


实现关联表查询：
-----一对一关联查询
现在有两张表，一张teacher一张class。class里面有一个teacher的外键。
现在要通过班级id去查班级信息，其中这个班级信息里面要包括老师信息。
方式一：
SELECT *FROM teacher t,class c WHERE c.teacher_id = t.t_id AND c_id=1		（联表查询）

方式二：		（两次查询，第二次查询使用第一次的查询结果）
SELECT *FROM class WHERE c_id = 1				先查班级，班级里面有teacherid,然后根据这个teacherid查出老师

SELECT *FROM teacher WHERE t_id =				这个等于后面就是刚才，查班级的时候会查出来一个teacherid，

方式一联表查询的代码：
<select id="getClass" parameterType="int" resultMap="getClassMap">
	SELECT *FROM teacher t,class c WHERE c.teacher_id = t.t_id AND c_id=#{id}
</select>
	
<resultMap type="Teacher" id="getClassMap">
	<id column="c_id" property="id"/>							班级表里面有个属性Teacher teacher
	<result column="c_name" property="name"/>			对于这个属性要使用<association> javaType写你这个属性的类型，不要column了
	<association property="teacher" javaType="Teacher">
		<id column="t_id" property="id"/>							因为这个对象的属性和数据库字段名不一致，所以还要写
		<result column="t_name" property="name"/>			这两行
	</association>
</resultMap>

方式二两次查询的代码：
<select id="getClass2" parameterType="int" resultMap="getClass2Map">
	SELECT *FROM class WHERE c_id=#{id}
</select>
<resultMap type="TeacherClass" id="getClass2Map">
	<id column="c_id" property="id"/>
	<result column="c_name" property="name"/>
	<association property="teacher" column="teacher_id" select="getTeacher">		这里的select是引用下面查teacher的（两次查询，引用第二次查询）
		<id column="t_id" property="id"/>												column="teacher_id"指的是我第一次查询得到的teacher_id的值，作为参数传给select="getTeacher"							
		<result column="t_name" property="name"/>								这样下面查teacher的时候#{id}里面就有值了
	</association>
</resultMap>
<select id="getTeacher" parameterType="int" resultType="Teacher">   这里写的是resultType，而数据库字段和类的属性有不一样
	SELECT t_id id, t_name name FROM teacher WHERE t_id =#{id}				所以下面的查询语句要写别名
</select>


一对多关联查询：
除了上面的表以外，新增了一个Student表，这个表里面有一个外键classid指向class表，一个学生可以对应多个班级
代码：
<select id="getClass" parameterType="int" resultMap="getClassMap">
	SELECT *FROM class c, student s WHERE c.c_id=s.class_id AND c.c_id=#{id}		
</select>
<resultMap type="TeacherClass" id="getClassMap">
	<id column="c_id" property="id"/>
	<result column="c_name" property="name"/>
	<collection property="students" ofType="Student">    ofType：指定集合中元素对象的类型
		<id column="s_id" property="id"/>										collection：做一对多关联查询用的
		<result column="s_name" property="name"/>						association：做一对一关联查询用的
	</collection>
</resultMap>


动态SQL与模糊查询：

调用存储过程：

Mybatis缓存:
正如大多数持久层框架一样，Mybatis同样提供了一级缓存和二级缓存的支持。
一级缓存的作用域是session,当session flush或close之后,该session中所有的缓存就将被清空。
二级缓存的作用域是Mapper(namespace)     是一个映射文件级的缓存

对于缓存数据更新机制，当某一个作用域（一级缓存session/二级缓存Namespace）进行了添加/修改/删除操作后
默认该作用域下所有select中的缓存将被clear

1、sqlSession.clearCache()   	清除session缓存
2、执行添加、修改、删除操作后   会清除session缓存   因为缓存是为了方便快速查找，你执行CUD操作后
数据库和缓存中数据肯定不一样了。下次也用不了了。所以肯定要先把它给清除掉。
3、不是同一个Session对象（比如说你把session关了，然后又开一个session。这就属于两个session）

总结概括（下面这些情况一级缓存就会默认被使用）：
1. 必须是同一个Session,如果session对象已经close()过了就不可能用了
2. 查询条件是一样的
3. 没有执行过session.clearCache()清理缓存
4. 没有执行过增删改的操作(这些操作都会清理缓存)

注：二级缓存要在映射文件添加一个<cache>在userMapper.xml中


Spring集成Mybatis:
有一个接口，这个接口里面写着增删改查的方法，然后这个接口对应一个映射文件。这个映射文件的nameSpace对应接口名的全类名
<mapper namespace="com.iflytek.mybatisspring.mapper.UserMapper">    namespace后面写对应接口的全类名
	<insert id="save" parameterType="User">							id必须与对应接口的某个对应方法名一致
		insert into s_user(user_name,user_birthday,user_salary)
		values (#{name},#{birthday},#{salary})
	</insert>
</mapper>

Spring集成Mybatis的spring的配置文件：
	<!-- 1、数据源 -->
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="url" value="jdbc:mysql://localhost:3306/mybatis"></property>
	<property name="username" value="root"></property>
	<property name="password" value="123"></property>
	<property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
</bean>
<!-- 2、mybatis的sqlSession工厂 -->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"></property>
	<property name="typeAliasesPackage" value="com.iflytek.mybatisspring.domain"></property>
</bean>
<!-- 3、mybatis自动扫描加载映射文件/接口 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value = "com.iflytek.mybatisspring.mapper"></property>
	<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>
<!-- 4、事务管理 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"></property>
</bean>
<!-- 5、使用spring的声明式事务 -->
<tx:annotation-driven transaction-manager="transactionManager"/>





-----------------------------------------------Spring部分-----------------------------------------------
spring是什么？
spring是一个容器框架，用于配置bean，并维护bean之间关系的框架。

在spring的配置文件applicationContext.xml中我们一般配置bean（这个bean可以是service/dao/domain/controller/数据源）
<bean id = "user" class = "com.iflytek.User">
		<property name = "name">
				这里就体现了注入的概念
				<value>Jimmy</value>
		</property>
</bean>
配置完这个bean的作用是：    当我们的这个spring框架加载的时候，spring就会去配置文件里看有没有配置bean,
如果你有配置bean它就会去实例化这个bean,并且把它自动装载到内存里面去。
现在假设spring框架加载了，它去配置文件里面找，看有没有配置bean的,找到上面有一个配置了User,
那么这时候spring就会去实例化这个bean,   相当于User user = new User();
这里的user是因为上面bean的id写的是user   假设上面bean的id写的是user11那么实例化的对象就是User user11 = new User();

上面写那个property的作用就相当于user.setName("Jimmy")

applicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml")
当这句话执行的时候，我们的spring容器（spring框架就加载了）就会被创建，同时applicationContext.xml中
配置的bean就会被创建到内存中，和上面说的也呼应。

总结：spring实际上是一个容器框架，它可以接管web层，业务层，dao层，持久层的各个组件，可以配置各种bean(action/service/domain/dao),并且可以维护bean与bean之间
的关系，当我们需要使用某个bean的时候，我们可以getBean(id)即可

什么是IOC？
英文全称Inverse Of Control  控制反转：所谓控制反转就是把创建对象（bean）和维护对象（bean）间的关系
的权利从程序中转移到spring容器（applicationContext.xml）中

什么是DI？
依赖注入，实际上和IOC是一个概念，只是spring的设计中认为DI更能表示spring的核心技术。
	

在spring的配置文件中配置bean的时候，这个bean不能是接口，可以是接口的实现类，因为接口不能被实例化。
你配置完bean后当配置文件被加载的时候，你配置的bean就会被实例化。如果这个bean是接口的话就会出问题。

BeanFactory factory = new XmlBeanFactory(new classPathResource("applicationContext.xml"))
factory.getBean("")
使用beanFactory去获取bean,当加载spring容器的时候，容器中的bean不会被立即实例化。当用到哪个bean的时候才实例化


bean的生命周期：
首先是实例化bean,就是当spring的配置文件被加载的时候，配置文件里面的bean会被实例化。怎么证明它被实例化了?
可以去这个bean的类里面，它会默认调用无参的构造器，你在构造器里面写一句话，运行如果控制台打印出来代表实例化bean了
实例化一旦成功了，下一步就是设置属性了（调用set方法去设置属性）。

aop(面向切面编程，针对所有的对象进行编程)


使用Autowire="byName"自动装配bean:
就比如说现在有一个Dog类，有一个Master类，Master里面有一个属性是dog。
按传统的方法就是在spring的配置文件里面，配置这两个bean。在master里面利用属性setter进去，
到时候你通过     Master master = (Master)ctx.getBean("master")得到Master对象，然后通过master.getDog().getDogName()当然可以获得dogName
现在我不这样弄，我在master这个bean直接写autowire="byName",就不用写下面的那个传统方法。
那么这个时候当spring配置文件加载的时候，就会去实例化master这个bean，让masterName=tom,因为master这个对象里面
还有一个dog属性，假设你没写autowire="byName"也没用setter注入，那么它会先让这个dog属性值等于null。这就
是为什么你这样master.getDog().getDogName()拿会报空指针异常。但是如果你写了autowire="byName"，spring就会去做这样一件事
因为master里面有一个属性叫dog,它就会去容器里面找看有没有一个bean叫dog的（即去找和dog这个属性名相同的bean。）,如果正好有那么这个关联关系
就会移鹄矗dog这个属性就会被加进去。如果说下面这个dog的这个bean的id不叫dog而是叫dog1,dog1和master里面
dog的属性名不一样就会找不到。

寻找和属性名相同的bean
<bean id = "master" class = "xxxxx.Master" autowire="byName">
		<property name ="masterName" value="tom"></property>
		
		<!--传统的方法  --!>
		<property name ="dog" ref="dog"></property>
<bean>

<bean id = "dog" class = "xxxxx.Dog">
		<property name ="dogName" value="小黄"></property>
		<property name ="dogAge" value=12></property>
<bean>



*****************************spring AOP*************************
AOP相关的术语：
1、通知（Advice）：
通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。
切面要完成的工作：比如说这个切面需要在方法调用前写日志。
何时执行这个工作：比如说在方法调用之前写日志，获知在方法调用之后写日志。

2、连接点（Joinpoint）
程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。

3、切入点(Pointcut)
通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称。

4、切面（Aspect）
通知和切入点共同组成了切面：时间、地点和要发生的“故事”。

5、目标（Target）
目标对象，即被代理的对象。如果没有AOP,那么它的逻辑将要交叉别的业务逻辑,有了AOP之后它可以只关注自己要做的事。

aop通过切点定位到特定的连接点。类比:连接点相当于数据库中的记录,切点相当于查询条件。切点和连接点
不是一对一的关系,一个切点可以匹配多个连接点。

例：
现在有一个接口叫Sleepable,所有具有睡觉能力的东西都可以实现该接口。
public interface Sleepable{
    void sleep(); 
}

然后写一个Human类，他实现了这个接口
public Human implements Sleepable{
		public void sleep(){
      System.out.println("睡觉了！梦中自有颜如玉！");
   }
}
好了，这是主角，不过睡觉前后要做些辅助工作的，最基本的是脱穿衣服，失眠的人还要吃安眠药什么的,
但是这些动作与纯粹的睡觉这一“业务逻辑”是不相干的，如果把这些代码全部加入到sleep方法中，是不是有违单一职责呢？，这时候我们就需要AOP了。

编写一个SleepHelper类，它里面包含了睡觉的辅助工作,用AOP术语来说它就应该是通知了，我们需要实现上面的接口
public class SleepHelper implements MethodBeforeAdvice,AfterReturningAdvice{
			 public void before(Method mtd, Object[] arg1, Object arg2)
            throws Throwable {
        System.out.println("通常情况下睡觉之前要脱衣服！");
    }
    
     public void afterReturning(Object arg0, Method arg1, Object[] arg2,
            Object arg3) throws Throwable {
        System.out.println("起床后要先穿衣服！");
    }
}

现在去spring的配置文件
<!--配置通知的这个bean -->
<bean id="sleepHelper" class="test.spring.aop.bean.SleepHelper"></bean>
OK!现在创建通知的工作就完成了.

第二步是进行配置

首先要做的是配置一个切点,据说切点的表示方式在Spring中有好几种，但是常用的只有两种：1.使用正则表达式 2.使用AspectJ表达式

<bean id="spleepPointcut" class="org.springframework.aop.support.JdkRegexpMethodPointcut">
  <property name="pattern" value=".*sleep"/>
</bean>
pattern属性指定了正则表达式，它匹配所有的sleep方法

切点仅仅是定义了故事发生的地点，还有故事发生的时间以及最重要的故事的内容,就是通知了，我们需要把通知跟切点结合起来，
我们要使用的通知者是:
org.springframework.aop.support.DefaultPointcutAdvisor

<bean id="sleepHelperAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
     <property name="advice" ref="sleepHelper"/>					把通知和切入点结合起来
     <property name="pointcut" ref="sleepPointcut"/>
</bean>

<!--配置代理对象 -->
<bean id="humanProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
	<!--配置代理接口集 -->
	<property name="proxyInterfaces" value="test.spring.aop.bean.Sleepable" />
	<!--
		如果代理多个接口，可以使用
		<property name="proxyInterfaces">
					<list>
								<value>test.spring.aop.bean.Sleepable</value>
								<value>xxxxxx</value>
					</list>
		</property>
	-->
	<!-- 把通知织入到代理对象 -->
	 <property name="interceptorNames" value="sleepHelperAdvisor" />
	 
	 <!-- 配置被代理对象-->
	 <property name="proxyInterfaces" value="test.spring.aop.bean.Sleepable" />
</bean>

测试代码：
public class Test {

    public static void main(String[] args){
        ApplicationContext appCtx = new ClassPathXmlApplicationContext("applicationContext.xml");
        Sleepable sleeper = (Sleepable)appCtx.getBean("humanProxy");
        sleeper.sleep();
    }
}

参考链接地址：http://blog.csdn.net/udbnny/article/details/5870076




springAOP使用AspectJ:
当我们调用一个目标方法，而这个目标方法和我在切面里面声明的这个注解所声明的方法匹配的时候。AOP框架应该自动的为那个方法所在的类
生成一个代理对象。然后在调用目标方法之前调用切面里面的方法。

使用AspectJ配置springAOP的小总结：
@Component
@Aspect
public class LoggingAspect {
	@Before("execution(public int com.iflytek.spring.aop.ArithmeticCalculatorImpl.add(int,int))")
	public void beforeMethod(JoinPoint joinPoint){
		List<Object>args = Arrays.asList(joinPoint.getArgs());
		System.out.println("The method begins"+args);
	}
}
配置AOP主要就是把切面配置好，切面是由切点和通知组成。先说通知，那么我就可以先写一个类LoggingAspect，这个类
里面写调用方法前要打印的日志，好，现在写一个方法，然后用@Before注解标识它是一个前置通知。通知有了下面就是
切点，("execution(public int com.iflytek.spring.aop.ArithmeticCalculatorImpl.add(int,int))")写的就是
哪个类的哪个方法。现在通知有了，切点也有了，可以组成一个切面了。所以我在这个类上面加一个@Aspect注解，
把这个有切点和前置通知的类声明为切面，但是这个切面要交给IOC容器管理吧，所以加一个@Component注解。
最后要让这个@Aspect注解生效，我需要在spring的配置文件里面加一个
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
这个的作用不但可以使@Aspect注解生效，还可以自动的("execution(public int com.iflytek.spring.aop.ArithmeticCalculatorImpl.add(int,int))")
这个方法所在的类生成代理对象。

如果要有多个切面可以使用@Order(1)来指明切面的优先级，值越小，优先级越高。

可以使用@Pointcut来声明切入点表达式。好处是后面的其他通知就可以直接使用方法名来引用当前的切入点表达式。
比如：
@Pointcut("execution(* com.iflytek.spring.aop.ArithmeticCalculatorImpl.*(..))")
public void declareJointPointExpression(){}    这个方法里面不需要写其他代码。         作用就是后面的通知就不用一个一个的写那一长串的东西了，直接引用切入点表达式的方法名就行了。比如：@Before("declareJointPointExpression()")







AOP编程：
面向切面编程。是对所有对象，或一类对象进行编程。（就是面向n多对象编程）
核心是，在不增加代码的基础上，还增加新的功能。

通过构造方法注入：
<bean id="car" class="com.iflytek.spring.beans.Car">
		<constructor-arg value="跑车"></constructor-arg>
		<constructor-arg value="兰博基尼"></constructor-arg>
		<constructor-arg value="200000"></constructor-arg>
</bean>
当字面值中包含特殊字符的时候，可以用<![CDATA[]]>把包含特殊字符的字面值包起来
比如说：<constructor-arg value="<跑车>"></constructor-arg>
value值里面写一个尖括号肯定就有问题了，这时候就可以使用<![CDATA[<跑车>]]>就ok了。

内部bean:
<bean id="person" class="com.iflytek.spring.beans.Person">
		<property name="name" value="小志"></property>
		<property name="car">															car是person里面引用类型的变量private Car car;
					<bean class="com.iflytek.spring.beans.Car">
						<property name="brand" value="拖拉机"></property>
						<property name="price" value="10"></property>
					</bean>
		</property>
</bean>

spring里面bean和bean的关系，可以是继承的关系。
比如说：
<bean id="address" class="com.iflytek.spring.beans.Address">
		<property name="city" value="beijing"></property>
		<property name="street" value="wudaokou"></property>
</bean>
下面我再有一个bean,属性什么的跟上面差不多。比如说就把街道换成是dazhongsi,那么可以这样写：
<bean id="address2" class="com.iflytek.spring.beans.Address">
		<property name="city" value="beijing"></property>
		<property name="street" value="dazhongsi"></property>
</bean>
明显这样写显得很冗余，可以直接使用继承
<bean id="address2" parent="address">
		<property name="street" value="dazhongsi"></property>    这就是子bean继承了父bean的配置,包括对父bean属性的继承，同时子bean也可以去覆盖父bean
																															比如说你父bean有一个属性被子bean继承了，子bean这时候也可以再注入一次这个属性，这样就把父bean的属性给覆盖了
</bean>

关于bean继承再多说一个知识点：
被继承的这个bean，也就是父bean它可以是一个实例bean，也可以就仅仅是一个模板bean（当spring的IOC容器加载的时候，不会去实例化这个bean）
模板bean仅仅就是为了给别人去继承的。
声明模板bean的方法：直接在bean上面加abstract=true就可以了。
<bean id="address2" class="com.iflytek.spring.beans.Address" abstract="true">
		<property name="city" value="beijing"></property>
		<property name="street" value="dazhongsi"></property>
</bean>
bean之间还有一个依赖关系，感觉没什么用，就不写了。

小知识：
java中equal和"=="的区别：equal比较的是对象的内容，"=="  比较的是对象的地址值，地址值一样肯定就是同一个对象。

bean的作用域：
就是可以在<bean scope=""></bean>bean上配置一个scope。
这个scope的值默认是singleton,你还可以写prototype。
singleton的意思就是，spring IOC容器实例化这个bean只会实例化一次，你通过getbean的方式拿这个bean，拿到的永远都是同一个bean
但是如果你写prototype的话，通过getbean去获取bean，每次获取到的都是新的bean。因为在spring IOC容器创建的时候，就不会去创建写了scope="prototype"的这个bean。当你需要这个bean的时候才去创建bean。有点懒加载的意思。

一般我们如果需要使用数据源的话，会把配置数据源的信息写到一个外部的属性文件中，如：db.properties
然后在spring的配置文件里面使用${}去引用db.properties里面的内容。（大概过程脑子里应该有印象）
现在有个问题就是，我把配置信息都写在db.properties属性文件里了。那么我在spring的配置文件里面怎么去引用它呢？
引用的方式：<context:property-placeholder location="classpath:db.properties"/>这样就可以把属性文件引用进去了。

 
SpEL:
spring的表达式语言。SpEL为bean的属性进行动态赋值提供了便利。基本的语法是#{}
1、可以使用SpEL为属性赋一个字面值，这个字面值可以是String类型或者基本数据类型
<bean id="address" class="xxxx.Address">
		<property name="name" value ="#{'北京'}"></property>   意义不大
</bean>
2、使用SpEL来引用其他的bean和其他bean的属性
<bean id="person" class="xxx.Person">
			<property name="car" value="#{car}"></property>				car是一个bean,在这里没写出来。如果不用SpEL，就需要使用ref="car"
			<property name="city" value="#{address.city}"></property>   address时一个bean，使用SpEL就可以动态的为属性添加值
</bean>


bean的生命周期：
首先是spring IOC容器创建bean,调用bean的无参的构造方法。其次是注入bean的属性，调用set方法。
然后如果你在bean的声明里init-method和destory-method,注入完属性后就会来调用init-method方法
如：
<bean id="car" class="xxx.Car" init-method="init2"></bean>        init-method引号里面的内容是因为我在car这个bean里面，写了一个方法叫init2,把这个init2这个方法当成初始化方法，你配一个init-method="init2"它就会把你bean里面写的这个init2方法当成初始化方法调用。destory-method类似
调完init方法后就可以获取到这个bean,获取到这个bean就可以干任何事了。最后当容器关闭的时候调用destory-method

bean的后置处理器：
首先你要先写一个bean的后置处理器，实现BeanPostProcessor接口。
public class AA implements BeanPostProcessor {

	public Object postProcessAfterInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println(bean+"..."+beanName);					这个方法在调init方法之后执行
		return bean;
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println(bean+"..."+beanName);					这个方法在调init方法之前执行
		return bean;
	}

}
然后需要在spring的配置文件里面配置一下：
<bean class="org.springframework.beans.factory.config.AA"></bean>
这样一个后置处理器就处理好了。

配置了后置处理器后bean的生命周期：
1、创建bean的实例
2、设置bean的属性值
3、将bean的实例传给postProcessBeforeInitialization方法，执行这个方法里面的东西
4、调用bean的初始化方法
5、将bean的实例传给postProcessAfterInitialization方法，执行这个方法里面的东西
6、bean可以使用了
7、当容器关闭的时候，调用destory-method方法


使用注解来配置bean:
spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件。
特定的组件包括：
---@Component     基本注解，标识了一个受spring管理的组件
---@Respository   标识持久层组件
---@Service				标识业务层组件
---@Controller		标识表现层组件

利用注解来建立bean和bean之间的引用关系：
比如说你在controller里面要引用service，    你要使用private UserService uservice
但是这个时候你用userservice还不行,这个时候用会报空指针异常的。
要使用需在上面加一个@Autowire注解，这个时候它就会去找看IOC容器里面有没有和UserService类型相匹配的bean,
有就给它加进来，你就可以用了。也就是说这个UserService已经被纳入IOC容器里面，然后你使用@Autowire注解，才能加进来
要是一开始UserService就不在IOC容器里面，你使用@Autowire注解就会抛异常。但是你也可以这样写@Autowire(required="false")
这样即使IOC容器里面没有UserSerrvice也不会抛异常，你要是打印一下userService,得到的是一个空。

关于@Autowire注解第二点：
比如说，你现在在Controller里面，需要使用private UserService userService  你可以使用@Autowire注解
但是这个UserService它是一个接口类型,它下面有两个实现类，这样你通过userService去调方法就会报错，它不知道要去找哪个实现类
一种解决办法就是你去希望调的实现类的上面写上@Service("userService")这样即使有两个实现类,它会去找类名第一个字母小写的那个实现类
第二种解决办法就是写@Autowire注解的同时还写一个注解@Qualifier("userServiceImpl")指明用这个调这个里面的方法。
总的概括就是针对一个接口有多个实现类的情况。

spring泛型依赖注入：


------------------------------------java基础IO流部分------------------------------------------------
java.io.File类
凡是与输入、输出相关的类、接口等都定义在java.io包下。

java语言是跨平台的

File中的方法，仅涉及到如何删除、修改、重命名文件等。只要是涉及文件内容的，File都是无能为力的，必须由IO流来完成。
File类的对象常作为IO流具体类的构造器的形参。

IO流用来处理设备之间的数据传输。

java程序中，对于数据的输入\输出操作以流的方式进行。

按照数据单位的不同分为：字节流（8bit）和字符流（16bit）        字节流：InputStream、OutputStream			字符流：Reader、Writer     （处理文本文件的叫字符流）
按照流向的不同分为：输入流和输出流。													 输入流：InputStream、Reader						输出流：OutputStream、Writer
按照角色的不同分为:节点流和处理流。

输入流是程序可以从中读取数据的流。
输出流是程序能向其写入数据的流。


关于字节和字符小知识：
一个汉字2个字节
一个字母一个字节
全角标点2个字节（中文默认是全角），半角标点一个字节（英文默认是半角）

示例：
@Test
public void test2() {
		File file = new File("abc.txt");
		FileInputStream fis = null;
		try {
			 fis = new FileInputStream(file);
			int len;
			byte[]b =new byte[5];
			while((len = fis.read(b))!= -1){			字节数组的大小是5，每次读5个。读到字节数组里面。    -1代表的是读到文件末尾了返回-1
				for(int i = 0;i < len;i++){					假设你要读的文件有7个字节，你每次读5个，第一次读5个字节，len=5,第二次只剩2个字节了，len=2。
					System.out.print((char)b[i]);
				}
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(fis != null){
				try {
					fis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
}

示例2：
	@Test
	public void test3(){
		File file = new File("hello.txt");
		FileOutputStream fos = null;
		try {
			fos = new FileOutputStream(file);
			fos.write(new String("hello i am jj").getBytes());
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			if(fos != null){
				try {
					fos.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

示例3（通过IO流实现文件复制）：
	@Test
public void test4(){
		File file1 = new File("abc.txt");
		File file2 = new File("abc1.txt");
		FileInputStream fis = null;
		FileOutputStream fos = null;
		try {
			fis = new FileInputStream(file1);
			fos = new FileOutputStream(file2);
			byte[] b = new byte[20];
			int len;
			while((len = fis.read(b)) != -1){
				fos.write(b, 0, len);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			if(fos != null){
				try {
					fos.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(fis != null){
				try {
					fis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
}

FileReader和FileWriter实现文件复制：
	@Test
	public void test6(){
		File file1 = new File("C:\\Users\\Administrator\\Desktop\\1.txt");
		File file2 = new File("C:\\Users\\Administrator\\Desktop\\2.txt");
		FileReader fr = null;
		FileWriter fw = null;
		try {
			 fr = new FileReader(file1);
			 fw = new FileWriter(file2);
			char[]c = new char[50];
			int len;
			while((len = fr.read(c))!=-1){
				fw.write(c, 0, len);
			}
		}catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			if(fr != null){
				try {
					fr.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(fw != null){
				try {
					fw.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
}

缓冲流实现文件复制：
	@Test
	public void test7(){
		File file1 = new File("C:\\Users\\Administrator\\Desktop\\1.txt");
		File file2 = new File("C:\\Users\\Administrator\\Desktop\\2.txt");
		FileInputStream fis = null;
		FileOutputStream fos = null;
		BufferedInputStream bis = null;
		BufferedOutputStream bos = null;
		try {
			 fis = new FileInputStream(file1);
			 fos = new FileOutputStream(file2);
			 bis = new BufferedInputStream(fis);
			 bos = new BufferedOutputStream(fos);
			byte[]b = new byte[50];
			int len;
			while((len = bis.read(b)) != -1){
				fos.write(b, 0, len);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(bis != null){
				try {
					bis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(fos != null){
				try {
					fos.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

--------------------------------------------------------------------------------------------------------

spring中的事务：
事务是开发的时候必用的一个功能。什么是事务？
事务是一系列的动作，他们被当做一个单独的工作单元，这些动作要么全部完成，要么全部不起作用。

事务在英文中是transaction，它有如下四个特性：
1、A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，
事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。
这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。

2、C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。

3、I (Isolation) 隔离性
所谓的隔离性简单点说是指并发的事务之间不会互相影响。
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被
其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经
结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

4、D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。

http://www.cnblogs.com/fjdingsd/p/5273008.html

使用springAOP处理事务。

spring中事务管理器的不同实现：
DataSourceTransactionManager、HibernateTransactionManager等等。
事务管理器以普通的bean形式声明在spring IOC中。

事务的传播行为：
说白了就是一个事务方法被另一个事务方法调用的时候，这个被调用的事务方法如何工作在事务中。是继续在现有
事务中运行，还是新开一个事务。

事务回滚的意思：一组业务的整体处理行为叫做一个事务。如果这组业务都能成功处理，我们才说事务时成功的。如果有任何差错
出现的话，我们都认为事务时不成功的，需要回滚来撤销之前的操作。举个例子，A转账转100元给B，要分两步，一步是把A的账户
减100，第二步时把B的账户加100。比如说这时候第一步成功了但第二步没有成功，第一步成功了，A的账户100元已经减了。但是整个
事务没有成功，就需要回滚。就是不保存刚才的操作，数据库恢复到操作前的状态。这时候事务没成功，A的账户也没减少。


一般我们在写spring的junit的单元测试的时候需要这么写

@Test
public void test1(){
		ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml")
		UserService us = ctx.getBean("userService");

}
上面是用junit的方法去加载配置文件，我们也可以换种方法。
就是用spring的测试方法，用这个方法首先你要加入spring-test的jar包

@RunWith(SpringJUnit4ClassRunner.class)         //这个就相当于继承了SpringJUnit4ClassRunner这个类
@ContextConfiguration(locations = {"classpath:applicationContext.xml"})      这个就相当于加载了配置文件
public class TestSpring{
	
	@Autowire
	private UserService userService;
	
	public void test1(){
			userService.getXXX();         如果不这样用的话要先加载配置文件才能进行以后的操作
	}

}

--------------------------------------------------------------------------------------------------------
什么是设计模式？
设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。
设计模式就像棋谱一样，不同棋局我们可以使用不同的棋谱，免去自己再思考和摸索。

单例模式：
它要解决的问题就是，使得一个类只能创建一个对象实例。

单例模式代码：（饿汉式）
public class TestSingleton {
	public static void main(String[] args) {
		Singleton s1 = Singleton.getSingleton();
		Singleton s2 = Singleton.getSingleton();
		System.out.println(s1==s2);
	}
}

class Singleton{
	private Singleton(){
		
	} 
	
	private static Singleton singleton = new Singleton();
	
	public static Singleton getSingleton(){
		
		return singleton;
	}
}
首先第一步私有化构造器，既然是单例，一个类只能创建一个对象。那么我肯定要把构造方法设置为私有的，不让外
部随便乱调用，不然想new多少对象就new多少对象，就不叫单例了。
第二步既然我把构造器声明为private的了，那么外部就调用不了了，我想要创建对象肯定只有在自己类里面给他创建好。
就是Singleton singleton = new Singleton();先不看前面的private static  我们的这个Singleton singleton = new Singleton();他其实是
处于属性的位置，只是在属性的位置上先给他初始化了。好，我们把它当成一个已经初始化的属性来看，为了体现封装性，
我们给他加上一个private   就变成了private Singleton singleton = new Singleton();现在对象就创建好了
第三步我们既然已经把对象创建好了，那么我们肯定要提供一个公共的方法来给外部调用去创建对象，既然给外部调用
那肯定要把这个方法声明为static,然后我返回上面创建的对象实例，因为静态方法里面只能调用静态变量，所以我们要
把它变成private static Singleton singleton = new Singleton();要加个static
这样一个单例模式就写好了。在测试方法里面看调用两次的引用是不是同一个就行了。

单例模式之懒汉式：
public class TestSingleton2 {
	public static void main(String[] args) {
		Singletons s1 = Singletons.getSingletons();
		Singletons s2 = Singletons.getSingletons();
		System.out.println(s1 == s2);
	}
}

class Singletons{
	private Singletons() {
		
	}
	private static Singletons singletons = null;
	
	public static Singletons getSingletons(){
		if(singletons == null){
			singletons = new Singletons();
		}
		return singletons;
	}
}
懒汉式是会存在线程安全问题的。    假设我现在有很多线程在执行，cpu负载会很重，现在其中一个线程来调用这个
方法，因为是首次调用，所以singletons == null是成立的，所以这个if语句我是可以进去的，好现在我进去以后，
走到singletons = new Singletons();这一步但这一步还没执行，因为进程有很多，cpu负载又重，所以这个进程被挂起了
也就是我还没new这个对象，现在又有一个进程来调用这个方法了，因为它还没被new 所以我singletons == null也是成立
的if语句也是能进的去的，这时候我接着往下走，就new了这个对象。但是刚才那个进程还被挂起在，现在我new完了，
刚才那个进程开始执行，它也new了一个对象。这样就出现了问题，一个类有两个对象实例，就不是单例模式了。
所以说懒汉式是线程不安全的。

--------------------------------------------------------------------------------------------------------
																								内部类
--------------------------------------------------------------------------------------------------------																								
在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。

内部类的分类：成员内部类、局部内部类

成员内部类：
这个内部类是和外部类的属性、方法等处于并列位置的称为成员内部类。
例如：
class Person{
	
	private String name;
	private int age;
	
	class Bird{
		
	}
	public void show(){
		
	}
}

局部内部类：
这个内部类是定义在外部类的方法里面的。就像变量一样，在方法外面定义称为全局变量，在方法内部定义称为局部变量。
例如：
class Person{
	
	private String name;
	private int age;
	
	class Bird{
		
	}
	public void show(){
		
	}
	
	public void method(){
		class A{										这就是一个局部内部类
			
		}
	}
}

* 成员内部类：
* 	是外部内的一个成员：①可以有权限修饰符（4个）②可以被static和final修饰③可以调用外部类的方法和属性
* 		
* 	具有类的特点：①被abstract修饰      ②可以在其内部定义方法、属性、构造器

* 关于内部类需要掌握的：
* 		1、如何创建内部类的对象
* 		2、如何区分调用外部类、内部类的变量（尤其指外部类和内部类变量重名的时候）
* 		3、局部内部类的使用


如何创建内部类对象：
public class TestInnerClass {
	public static void main(String[] args) {
		//创建静态内部类，可以直接通过外部类调用静态内部类的构造器
		Person.Dog dog = new Person.Dog();
		
		//创建非静态内部类的对象，必须先创建外部类的对象，通过外部类的对象调用内部类的构造器
		Person p = new Person();
		Person.Bird bird = p.new Bird();
	}
}

class Person{
	
	private String name;
	private int age;
	
	class Bird{
		
	}
	
	static class Dog{
		
	}
	public void show(){
		
	}
	
	public void method(){
		class A{
			
		}
	}
}

如何区分调用外部类、内部类的变量（尤其指外部类和内部类变量重名的时候）：
class Person{
	
	private String name = "jack";
	private int age;
	
	class Bird{
		private String name = "杜鹃";
		public void setName(String name) {
			this.name = name;    
			System.out.println(name);//这个name打印的值肯定是传过来的值
			System.out.println(this.name);//这个name打印的值是杜鹃，这个this指的是Bird谁调我这个方法this指的就是谁，很显然我要创建一个Bird对象，然后来调set方法。所以这里的this指的是Bird。this.name当然也指的是Bird的属性name
			System.out.println(Person.this.name);//这里打印的值就是jack
		}
		
		
	}
}

-------------------------------------------------------------------------------------------------------
java中如何创建多线程？
继承Thread类与实现Runnable接口

--------一些基本概念-----
程序（program）:为完成某种特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。

进程（process）:是程序的一次执行过程，或是正在运行的一个程序。如运行中的QQ。程序是静态的，进程是动态的。

线程（thread）:进程可以进一步细化为线程，是一个程序内部的一条执行路径。
若一个程序可同一时间执行多个线程，就是支持多线程的。

比如说360啊QQ啊，如果你不去运行它，它就是一个程序。只有你去运行它，它去加载了，它就是一个进程。相应的
你在任务管理器里面也能看到你所运行的进程。这些进程都是加载到内存中占用你的CPU和内存资源的。
比如说你现在把360打开运行它，它就是一个进程。打开后你可以点电脑体检，然后点病毒查杀。这两个操作时同时
进行的。它其实就是两个线程同时在运行。也就是说360支持多线程。
理解了上面概念后就会理解window操作系统是支持多进程的这句话。就是说我同时可以运行多个进程。

何时需要多线程？
1、程序需要执行两个或多个任务的时候    比如说QQ这个程序（我不运行它的时候它就是一个程序）我在发送文件的时候
同时也需要打字和对方聊天。这就是一个进程执行了两个任务，我肯定是要它支持多线程的，不然同时执行不了。

2、程序需要实现一些需要等待的任务的时候，比如说需要两个任务之间相互配合的操作，一个线程执行需要另一个线程
来配合，这肯定也需要使用多线程。

创建多线程代码：
需求：创建一个子线程，完成1-100之间自然数的输出。同样地，主线程执行同样的操作。
public class TestThread {
	public static void main(String[] args) {
		//创建一个子类对象
		SubThread st = new SubThread();
		st.start();  //其实这里调用的是Thread类里面的start方法，作用是启动此线程，调用相应的run()方法。
		//在这里我们不能把st.start()换成st.run()这样的话就是一个简单的对象调方法不能称为多线程。因为你线程根本没启动。start方法有两个功能一个是启动线程第二个是调run方法。
		for(int i = 1;i<=100;i++){
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}
//创建多线程第一步1.继承Thread类
class SubThread extends Thread{
	//2.重写Thread类的run()方法，然后我们在这个方法里面写我们要实现的功能。
	public void run(){
		for(int i = 1;i<=100;i++){
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}



 * Thread常用方法：
 * 1.start():启动线程并执行相应的run方法。
 * 2.run()方法：子线程要执行的代码放入到run()方法里面
 * 3.currentThread()：Thread的一个静态方法，通过这个方法我就可以把当前的线程调取出来，返回的还是一个Thread
 * 4.getName():获取此线程的名字。
 * 5.setName():设置此线程的名字。
 * 
 * 6.yield():一旦你执行一个线程的yield()方法，当前这个线程就会释放CPU的执行权。
 * 如果你的这个CPU是单核的话，这两个线程在执行的时候就会去抢这个CPU的执行权，所以你每次执行的结果都是不一样的。
 * 所以一旦你某个线程执行了yield()方法以后就会强制的要你释放CPU的执行权。但是把执行权释放了以后，下一刻CPU的
 * 执行权是谁的还不好说，有可能还这个线程给抢到了，那么它就继续执行。
 *
 * 7.join()方法：在A线程中调用B线程的join()方法，表示当执行到此方法的时候，让A线程停止执行，让B线程参与进来执行，
 * 直至B线程执行完毕。然后A线程再接着执行。
 *
 * 8.sleep(long l):显示的让当前线程睡上多少毫秒
 
yield()方法代码示例：
public class TestThread1 {
public static void main(String[] args) {
	//创建一个子类对象
	SubThread1 st = new SubThread1();
	st.setName("子线程1");   //因为SubThread1是Thread类的子类，我当然就能调用Thread类的setName方法。
	st.start(); 
	Thread.currentThread().setName("******主线程");
	for(int i = 1;i<=100;i++){
		System.out.println(Thread.currentThread().getName()+":"+i);
		if(i % 10 ==0){
			Thread.currentThread().yield();     当输出的数能被10整除的时候，我就调用主线程的yield()方法，这样主线程就会把CPU的执行权给释放出来。
		}
	}
}
}


join()方法代码示例：
public class TestThread1 {
	public static void main(String[] args) {
		SubThread1 st = new SubThread1();
		st.setName("子线程1");   
		st.start(); 
		Thread.currentThread().setName("******主线程");
		for(int i = 1;i<=100;i++){
			System.out.println(Thread.currentThread().getName()+":"+i);
			if(i==20){      							//意思就是当你这个主线程执行到20的时候我就强制的
				try {												//让子线程参与进来，直到你这个子线程执行完之后，再考虑主线程的执行。
					st.join();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}


sleep()方法代码示例：
class SubThread1 extends Thread{
	public void run(){
		for(int i = 1;i<=100;i++){
			try {
				Thread.currentThread().sleep(1000L);     在这里有一点要注意的是，这个方法是有异常的，正常我把鼠标放在有异常的代码处，它会提示我是用try catch还是throws
			} catch (InterruptedException e) {				但是在这里它只提示用try catch而没有提示用throws为什么呢？因为被重写的方法本身不能比父类方法抛更大的异常，你要是进Thread这个类里面看，它的run()方法根本就没有抛异常，所以你子类重写的run()方法不能比父类抛更大的异常，所以子类的run()方法也不能抛异常只能try catch
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName()+":"+i);
		}
	}
}


通过实现Runnable接口的方式来创建多线程：
-----步骤：
1、创建一个实现Runnable接口的类（先要实现Runnable接口）
2、重写接口里面的抽象（run）方法（在抽象方法里面写你这个线程要完成的某项功能）
3、创建一个Runnable接口实现类的对象，把它作为形参传递给Thread的构造器中
4、创建Thread类的对象，此对象即为一个线程
5、调用start()方法启动线程

----代码说明：
public class TestThreadImp {
	public static void main(String[] args) {
		PrintNum p = new PrintNum();
		//p.start()     我们通过继承的方式，只需要调用start()方法就可以了，但在这里不行。因为start()方法是Thread类里面的方法，你通过实现Runnable接口的方法，Runnable接口里面根本没有start()方法，所以在这里用时根本行不通的
		//注意：要想启动一个多线程，必须调用start()方法，而start()方法又是Thread类里面的方法，所以我们用实现的方式来创建多线程要想办法和Thread类发生点联系，这样就能调他的start()方法了。
		//Thread这个类有一个构造器Thread t = new Thread(Runnable target)它里面可以传一个Runnable接口的实现类
		Thread t = new Thread(p);
		/*
		 * 这个start()方法的作用是开启一个线程并调用这个线程的run()方法
		 * 你进到Thread类里面去看它的源码就会发现这个run()方法是这样写的:
		 * public void run(){
		 * 		if(target != null){
		 * 			target.run()     而这个target就是传过来的Runnable接口的实现类p
		 * 		}
		 * }
		 */
		t.start();				//所以这里start()方法开启一个线程，并调用run()方法，调的是接口实现类的run()方法
		
		//再创建一个线程
		Thread t2 = new Thread(p);
		t2.start();
	}
}

class PrintNum implements Runnable{
	@Override
	public void run() {           //这里run()方法是重写接口里面的抽象方法
		for(int i = 1;i < 100;i++){
			if(i % 2 ==0){
				System.out.println(Thread.currentThread().getName()+":"+i);
			}
		}
	}
}


继承的方式和实现的方式创建多线程比较：
联系：
这个Thread类它其实是继承了Object类，并实现了Runnable接口，所以他里面才会有run()方法的
public class Thread extends Object implements Runnable
实现的方式就直接去实现Runnable接口了

哪个方式更好？
答：实现的方式优于继承的方式。原因：
①避免的java单继承的局限性       比如说你现在有一个学生类可以通过继承和实现的方式来创建多线程，但是你这个线程想要继承一个 人 这个类，这时候你通过继承就不好创建了，因为java是单继承的，但是通过实现就可以很好解决这个问题。
②如果多个线程要操作同一份资源(或数据)，更适合使用实现的方式。


只使用单个线程完成多个任务，肯定比用多个线程来完成用的时间短，为何扔需要多线程呢？
上面这句话的理解：
比如说你拷贝东西，你是同时拷贝两个文件的时间短还是我把一个文件拷贝完之后紧接着拷贝下一个文件的时间短呢？
肯定是第二种方式拷贝文件的时间短，因为第二种方式CPU的执行权全都放在你这个线程上，如果用第一种方式CPU一会
要执行这个线程另一会又要执行另一个线程，中间多了CPU切换的时间。这个时间虽然很短，但是你如果文件很大，一累加
时间就长了。

多线程的优点：
1、提高应用程序的响应。对图形化界面更有意义，可增强用户体验。（在图形化界面，如果你不用多线程，你同一时间只能做一件事，不能同时运行两个进程）
2、提高计算机系统CPU的利用率。（如果你用多线程，多个任务同时在进行，CPU会一直不停的切换运行就一直处在运行状态，但是如果你用单线程，这个线程做完了，你再开下一个线程，在这中间的一段时间CPU就会闲下来）
3、改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。


------线程安全问题：
以上面售票的例子为例：
/*
 * 通过使用实现Runnable接口的方法来售票
 */
public class TestWindow1 {
	public static void main(String[] args) {
		Window1 w1 = new Window1();
		Thread t1 = new Thread(w1);
		t1.setName("窗口1");
		t1.start();
		Thread t2 = new Thread(w1);
		t2.setName("窗口2");
		t2.start();
		Thread t3 = new Thread(w1);
		t3.setName("窗口3");
		t3.start();
	}
}

class Window1 implements Runnable{
	
	private int tickets = 100;
	@Override
	public void run() {
		while(tickets > 0){
			try {
				Thread.currentThread().sleep(10);          //这里是为了显示效果我额外加的代码
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName()+"票号为："+tickets--);
		}
	}
}
上面的代码就存在着线程安全问题，假如我这个tickets一直减减，减到tickets=1的时候，我进while语句，tickets>0是成立的
进来后我就被睡了10毫秒，现在第二进程来了，因为我第一个进程被睡眠了，还没执行到tickets--，所以这时候
tickets还是等于1，第二个进程进来后又睡了10毫秒，同样的没执行tickets--，第三个进程又进来，等它们都醒了后
三个进程都在while语句里面都将继续往下执行就会出现tickets=0或者tickets=-1的情况。这就是线程安全问题。

上面存在线程安全的原因就是：由于一个线程在操作共享数据(tickets)的时候，在未执行完毕的情况下，其他的线程
又参与进来了，导致共享数据存在安全问题。假如你不同的线程操作的是不同的数据，就不会存在这个问题。

如何解决线程安全问题？
必须让一个线程在操作共享数据的时候其他的线程不能参与进来，等这个线程操作完成后其他的线程才有机会参与进来

在java中如何实现线程的安全？使用线程同步机制
方式一：同步代码块
synchronized (同步监视器) {
			//需要被同步的代码块(即为操作共享数据的代码)
}
1、共享数据：多个线程共同操作的同一个数据（变量）
2、同步监视器：由一个类的对象来充当(任何一个类的对象都行)哪个线程获取此监视器，谁就执行大括号里被同步的代码。俗称：锁
要求：所有的线程必须共用一把锁。
方式二：同步方法
将操作共享数据的方法声明为synchronized。即此方法为同步方法，能够保证当其中一个线程执行此方法的时候，
其他线程在外等待直至线程执行完此方法。
注意；同步方法的锁是当前对象。


上述有线程安全的代码这样改一下，就不会有线程安全问题了(同步代码块方式)：
public class TestWindow1 {
	public static void main(String[] args) {
		Window1 w1 = new Window1();
		Thread t1 = new Thread(w1);
		t1.setName("窗口1");
		t1.start();
		Thread t2 = new Thread(w1);
		t2.setName("窗口2");
		t2.start();
		Thread t3 = new Thread(w1);
		t3.setName("窗口3");
		t3.start();
	}
}

class Window1 implements Runnable {

	private int tickets = 100;
	Object obj = new Object();    ①     在这里new一个对象给下面充当锁，是完全没有问题的

	@Override
	public void run() {
	
		//Object obj = new Object(); 如果我把上面①的那行代码写在这里，就有问题了。因为我每一个线程进来都会new一个这个对象充当锁，这样不同的线程就用的是各自的锁。就会出现问题。
		synchronized (obj) {     这里传入的对象可以是任何一个对象
			while (tickets > 0) {
				try {
					Thread.currentThread().sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + "票号为："
						+ tickets--);
			}
		}
	}
}

使用同步方法的方式：
public class TestWindow1 {
	public static void main(String[] args) {
		Window1 w1 = new Window1();
		Thread t1 = new Thread(w1);
		t1.setName("窗口1");
		t1.start();
		Thread t2 = new Thread(w1);
		t2.setName("窗口2");
		t2.start();
		Thread t3 = new Thread(w1);
		t3.setName("窗口3");
		t3.start();
	}
}

class Window1 implements Runnable {

	private int tickets = 100;
	@Override
	public void run() {
			show();
	}
	
	public synchronized void show(){
		while (tickets > 0) {
			try {
				Thread.currentThread().sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName() + "票号为："
					+ tickets--);
		}
	}
}
这个就是我新定义一个方法，把操作共享数据的代码放在这个里面，然后加上synchronized修饰，在run()方法里来调这个方法。


在java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应一个互斥锁的标记，这个标记
用来保证在任意时刻，只能有一个线程访问该对象。（意思就是哪个线程访问该对象就相当于握住了这把锁，就有这个线程
来执行，执行完后退出，释放锁。）

解决懒汉式线程安全问题：
public class TestSingleTone {
	public static void main(String[] args) {
		SingleTon s1 = SingleTon.getSingleTon();
		SingleTon s2 = SingleTon.getSingleTon();
		System.out.println(s1 == s2);
	}
}

class SingleTon{
	private SingleTon(){
		
	}
	private static SingleTon singleTon = null;
	
	public static SingleTon getSingleTon(){
		synchronized (SingleTon.class) {       //使用同步机制，由本身类的对象充当锁，哪个线程先进来了就会握住这把锁，其他测线程就只能等待
			if (singleTon == null) {
				singleTon = new SingleTon();
			}
		}
		return singleTon;
	}
}
但是这里有个弊端，也算是多线程的弊端吧，就是在同一时间内我使用了同步机制，就只能有一个线程去访问共享资源
其他的线程就只能在那里等着，效率变低了。


在使用同步机制的时候会导致一类问题：线程死锁问题。

死锁：
不同的线程分别占用对方需要的同步资源部放弃，都在等待对方放弃自己需要的同步资源，就形成了线程死锁。
代码：
public class TestDeadLock {

	static StringBuffer sb1 = new StringBuffer();
	static StringBuffer sb2 = new StringBuffer();

	public static void main(String[] args) {

		new Thread() {
			public void run(){
				synchronized (sb1) {
					try {
						Thread.currentThread().sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sb1.append("A");
				}
				synchronized (sb2) {
					sb2.append("B");
					System.out.println(sb1);
					System.out.println(sb2);
				}
			}
		}.start();

		new Thread() {
			public void run(){
				synchronized (sb2) {
					try {
						Thread.currentThread().sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					sb1.append("C");
				}
				synchronized (sb1) {
					sb2.append("D");
					System.out.println(sb1);
					System.out.println(sb2);
				}
			}
		}.start();
	}
}
首先一个线程进来会先握住sb1这把锁，然后要想往下执行，把run()方法执行完，它必须要握住sb2这把锁。但是sb2
这把锁在下面的那个线程已经被握住了，所以要想握住sb2这把锁只有等下面这个线程把锁释放。但是下面这个线程又
在等上面的这个线程把sb1这把锁给释放掉，它才能把run()方法执行完。这样就形成了死锁。


线程通信(其实就三个方法)：
wait():令当前线程挂起并放弃CPU、同步资源，使别的线程可以访问并修改共享资源，而当前线程排队等候再次对资源
的访问。
notify():唤醒正在排队等待同步资源的线程中优先级最高者结束等待。
notifyAll():唤醒正在排队等待资源的所有线程结束等待。

注意：这三个方法是java.lang.Object提供的，而且只有在synchronized方法或synchronized代码块中才能使用，否则
会报异常。

--------------------------------------------------------------------------------------------------------
																					网络编程
--------------------------------------------------------------------------------------------------------
要想实现在网络上的一个通信要满足两个要素：
①IP和端口号         相当于我如何来定位网络中的一台主机，主要通过ip来实现主机的定位，要实现哪些应用程序还需要通过端口号
②网络通信协议       定位好我如何来进行通信呢，需要满足一定的通信协议。

网络编程的目的：
直接或间接的通过网络协议与其他计算机进行通讯

网络编程中有两个主要的问题：
--如何准确的定位网络上的一台或多台主机
--找到主机后如何可靠高效地进行数据传输

ip地址：唯一标识Internet上的计算机
端口号：标识正在计算机上运行的进程(程序)    不同的进程有不同的端口号
端口号和ip地址的组合得出一个网络套接字。

TCP协议：
使用TCP协议前，须先建立TCP连接，形成传输数据通道。
传输数据前，采用"三次握手"方式，是可靠的
在连接中可进行大数据量的传输
传输完毕，须释放已建立的连接，效率低

UDP协议：
将数据、源、目的封装成数据包，不需要建立连接
每个数据包的大小限制在64K以内
因无需连接，故不可靠
发送数据结束时无需释放资源，速度快。


如何去获取一个ip地址？
通过创建InetAddress这个类来实现。代码如下：
/*
 * InetAddress:位于java.net包下
 * InetAddress用来代表IP地址，一个InetAddress对象就代表一个IP地址
 */
public class TestInetAddress {
	public static void main(String[] args) throws Exception {
		InetAddress address = InetAddress.getByName("www.baidu.com");
		InetAddress address2 = InetAddress.getLocalHost();  //获取本机的ip地址
		System.out.println(address2.getHostName());   //获取ip地址对应的域名
		System.out.println(address2.getHostAddress());//获取ip地址
	}
}


Socket:
--网络通信其实就是Socket间的通信
--通信的两端都要有Socket，是两台机器通信的端点。
--Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输
--一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端


关于网络通信的案例代码：
案例一：
---需求,客户端给服务端发送信息，服务端将此信息输出到控制台上
public class TestTCP1 {
	@Test
	public void client(){
		Socket socket = null;
		OutputStream outputStream = null;
		try {
			//1.创建一个Socket对象，通过构造器指明服务端的ip地址，以及接收程序的端口号，我只有知道服务器的ip地址和那个应用的端口号我才能去连上那个应用
			socket = new Socket(InetAddress.getByName("127.0.0.1"), 9090);
			//2.得到一个OutputStream对象，发送数据
			outputStream = socket.getOutputStream();
			//3.具体的输出过程
			outputStream.write("客户端向服务的发送的信息，收到请显示到控制台上".getBytes());
		} catch (UnknownHostException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(outputStream != null){
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
	
	@Test
	public void server(){
		Socket socket = null;
		InputStream inputStream = null;
		try {
			//1.创建一个ServerSocket对象，通过构造器指明自身的端口号
			ServerSocket serverSocket = new ServerSocket(9090);//在这里要指明别的机器可以访问我这个应用的端口号是多少
			//2.调用accept()方法返回一个Socket对象
			socket = serverSocket.accept();
			//3.调用Socket对象的getInputStream()方法获取一个从客户端发来的输入流
			inputStream = socket.getInputStream();
			//4.对获取到的输入流的一些操作(你可以把接收到的输入流的数据打印到控制台上或者输出到一个文件里面等等)
			byte[] b = new byte[20];
			int len;
			while((len = inputStream.read(b))!=-1){
				String str = new String(b, 0, len);
				System.out.println(str);
			}
			//我们还可以看一下是谁发送的请求信息
			System.out.println(socket.getInetAddress().getHostName());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			if(inputStream != null){
				try {
					inputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
//通过上面的例子我们就可以发现网络编程实际上就是Socket编程
}


案例二：
---需求,客户端给服务端发送信息，服务端将此信息输出到控制台上,同时发送"已收到"信息给客户端
public class TestTCP2 {
	@Test
	public void client(){
		Socket socket = null;
		OutputStream outputStream = null;
		InputStream inputStream = null;
		try {
			socket = new Socket(InetAddress.getByName("127.0.0.1"), 9090);
			outputStream = socket.getOutputStream();
			outputStream.write("客户端现在要给服务端发送信息了".getBytes());
			
			//通过这个shutdownOutput()方法告诉服务端我已经输入完毕
			socket.shutdownOutput();																	①
			inputStream = socket.getInputStream();
			byte[]b = new byte[20];
			int len;
			while((len = inputStream.read(b))!= -1){
				String str = new String(b, 0, len);
				System.out.println(str);
			}
		} catch (UnknownHostException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(inputStream != null){
				try {
					inputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(outputStream != null){
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
	
	@Test
	public void server(){
		ServerSocket serverSocket = null;
		Socket socket = null;
		InputStream inputStream = null;
		OutputStream outputStream = null;
		try {
			serverSocket = new ServerSocket(9090);
			socket = serverSocket.accept();
			inputStream = socket.getInputStream();
			byte[] b = new byte[20];
			int len;
			while((len = inputStream.read(b)) != -1){            ②
				String str = new String(b, 0, len);
				System.out.println(str);
			}
			
			outputStream = socket.getOutputStream();						③
			outputStream.write("我是服务端，我收到你客户端发送的信息了".getBytes());			④
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(outputStream != null){
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(inputStream != null){
				try {
					inputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(serverSocket != null){
				try {
					serverSocket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
注意：
①处的代码很重要，因为我这个案例的需求是客户端给服务端发送信息，然后服务端再给客户端回送一个响应信息
如果没有①处的代码，执行的结果就是光客户端给服务端发送的信息打印出来了，但服务端给客户端发送的信息却没有
打印出来。原因是你客户端给服务端发送信息,然后我服务端收到后要用read()方法去读你这个信息，但是read()方法是
一个阻塞式的方法(缓冲流里面的read()方法不是阻塞式的),就是我不知道你这个信息有没有发送完，你发送信息过来我
就读，但是因为不知道你有没有发送完，所以我就会一直在那等，就算你客户端信息发送完了,但我不知道，所以还会
一直在那里等着，所以③④处的代码根本执行不到，即服务端的响应信息根本没发送出去，客户端当然就收不到了。

解决方法:
就是加上①处的代码,显示的告诉服务端我信息发送完了。服务端的read()方法就不会一直在那等了，就会执行下面的
代码。这样客户端就能接收到服务端发送的信息了。


案例三：
---需求,从客户端发送文件服务端,服务端保存到本地,并返回"发送成功"给客户端。并关闭响应的连接。
代码实现：
public class TestTCP3 {
	@Test
	public void client(){
		Socket socket = null;
		FileInputStream fis = null;
		OutputStream outputStream = null;
		try {
			socket = new Socket(InetAddress.getByName("127.0.0.1"), 9090);
			fis = new FileInputStream(new File("2.jpg"));       我要发文件给客户端，那我肯定要先把本地文件给它读出来
			outputStream = socket.getOutputStream();
			byte[]b = new byte[1024];
			int len;
			while((len = fis.read(b)) != -1){
				outputStream.write(b, 0, len);
			}
			socket.shutdownOutput();           ****重要
			
			InputStream inputStream = socket.getInputStream();
			byte[]b1 = new byte[1024];
			int len1;
			while((len1 = inputStream.read(b1)) != -1){
				String str = new String(b1, 0, len1);
				System.out.println(str);
			}
		} catch (UnknownHostException e) {
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(outputStream != null){
				try {
					outputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(fis != null){
				try {
					fis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
	
	@Test
	public void server(){
		ServerSocket serverSocket = null;
		Socket socket = null;
		InputStream inputStream = null;
		FileOutputStream fos = null;
		try {
			serverSocket = new ServerSocket(9090);
			socket = serverSocket.accept();
			inputStream = socket.getInputStream();
			
			fos = new FileOutputStream(new File("4.jpg"));
			byte[]b = new byte[1024];
			int len;
			while((len = inputStream.read(b)) != -1){
				fos.write(b, 0, len);
			}
			
			OutputStream outputStream = socket.getOutputStream();
			outputStream.write("客户端发送的信息已经收到了".getBytes());
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(fos != null){
				try {
					fos.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(inputStream != null){
				try {
					inputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(socket != null){
				try {
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(serverSocket != null){
				try {
					serverSocket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}


UDP网路通信：(了解即可)
---类DatagramSocket和DatagramPacket实现了基于UDP协议的网络程序
---UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能
确定什么时候可以抵达。
---DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
---UDP协议中每个数据报都给出了完整信息，因此无需建立发送方和接收方的连接。


URL编程：
URL：统一资源定位符。它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源。
浏览器通过解析给定的URL可以在网络上查找响应的文件或其他资源。

URL基本结构：
<传输协议>://<主机名>:<端口号>/<文件名>
例如：http://192.168.1.100:8080/helloworld/index.jsp

URL的方法openStream():能从网络上读取数据 

代码示例：
public class TestURL {
	//URL:统一资源定位符。一个URL对象对应着网络上的一个资源。
	//我们可以通过URL的对象调用其相应的方法,将此资源读取("下载")
	public static void main(String[] args) {
		InputStream inputStream = null;
		URL url = null;
		try {
			url = new URL("http://localhost:8080/examples/hello.txt");
//		System.out.println(url.getHost());
			inputStream = url.openStream();
			byte[]b = new byte[1024];
			int len;
			while((len = inputStream.read(b)) != -1){
				String str = new String(b, 0, len);
				System.out.println(str);      在这里就可以把你url对应的资源内容给打印出来了     要是你url对应的资源是一个视频文件你拿到这个inputstream后,还可以new一个FileOutputStream把它写到一个文件里实现下载。
			}
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			try {
				inputStream.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
																						集合
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java集合概述：
java集合可分为Collection和Map两种体系
Collection接口：
			>>>Set:元素无序、不可重复的集合。
			>>>List:元素有序、可以重复的集合。
Map接口：
具有映射关系"key-value对"的集合



存储对象可以考虑：①数组②集合
数组存储对象：Student[]stu = new Student[20];代表我创建了一个长度为20的Student类型的数组。
			<弊端：①一旦创建,长度不可变。比如说上面我数组的长度是20,现在假如我要往里面存第21个对象就没法存了,除非你重新创建一个数组。																						
						 ②真实的数组存放的对象的个数是不可知的。比如说你数组长度是20但你数组里面到底存了多少个对象,不知道。如果是集合的话我可以通过它的size()方法知道集合的长度。																				

Collection接口下面有两个子接口List和Set。List和Set是继承于Collection的。List和Set下面有对应的实现类。

集合中的一些方法：
@Test
public void testCollection1(){
		Collection coll = new ArrayList<>();
		coll.add("aa");
		coll.add(123);
		//1.查看集合的大小
		System.out.println(coll.size());
		
		Collection coll2 = Arrays.asList("a","b","c");//Collections是集合的一个工具类,Arrays是数组的一个工具类,Arrays.asList()返回的是一个List类型的集合,而List是Collection的子接口,所以我在这里写Collection也是可以的
		//2.addAll(Collection coll)
		coll.addAll(coll2);     //里面传入的参数是一个集合,将coll2中的元素加入到当前集合中。
		System.out.println(coll.size());
		
		//3.查看集合是否为空
		System.out.println(coll.isEmpty());
		//4.清空集合中的元素
		coll.clear();
}

@Test
public void testCollection2(){
		Collection coll = new ArrayList();
		coll.add("aa");
		coll.add(123);
		//5.contains(Object obj):判断集合中是否包含指定的obj元素
		boolean b = coll.contains("aa");
		System.out.println(b);
		Collection coll1 = new ArrayList();
		coll1.add(123);
		//6.containsAll(Object obj)判断当前集合中是否包含coll集合中所有的元素
		boolean b1 = coll.containsAll(coll1);
		System.out.println(b1);
		
		//7.retainAll(Collection coll)保留coll集合和coll1集合共有的部分,就是两个集合取交集,然后再赋给当前集合
		coll.retainAll(coll1);
		System.out.println(coll);
		
		
		//8.remove(Object obj)删除集合中的元素
		coll.remove(123);
		
		//9.toArray()将集合转化成数组
		Object[] array = coll.toArray();
		for(Object o :array){
			System.out.println(o);
		}
}


遍历集合的两种方法：
①增强for循环②迭代器
代码示例：
@Test
public void testForeach(){
		Collection coll = new ArrayList();
		coll.add(123);
		coll.add("AA");
		coll.add("cc");
		for(Object co : coll){
			System.out.println(co);
		}
}
	
@Test
public void testIterator(){
		Collection coll = new ArrayList();
		coll.add(123);
		coll.add("AA");
		coll.add("cc");
		
		Iterator iterator = coll.iterator();
		while(iterator.hasNext()){
			System.out.println(iterator.next());
		}
}


>>>>>>List集合方法：
void add(int index, Object ele)      在指定的索引位置添加元素
boolean addAll(int index, Collection eles)
Object get(int index)              获取指定位置的元素
int indexOf(Object obj)						返回obj在集合中首次出现的位置							相对于Collection中新增加的方法,因为List集合是有序的,所以方法参数多了一个下标。
int lastIndexOf(Object obj)				返回obj在集合中最后一次出现的位置,没有的话返回-1
Object remove(int index)					删除指定索引处的元素
Object set(int index, Object ele)  设置指定索引处的元素为ele
List subList(int fromIndex, int toIndex)  返回一个从fromIndex到toIndex的一个子list集合（前包括后不包括）

List接口有两个实现类：
ArrayList(主要实现类)和LinkedList
ArrayList底层是用数组来实现的,LinkedList底层是用链表来实现的。
现在来说说它两之间的关系：
List集合有一个方法add(int index, Object ele),可以在指定索引处添加一个对象,这时候如果实现类是ArrayList,
因为它底层是用数组实现,比如说你在3号位置添加一个元素,那么3号位置后面的元素都要后移一个原来3号位置元素变为
4号位置,4号位置变为5号位置。如果这时候集合里面元素有很多假设有一万条这样插入代价就很大了。在3号位置插入
一个元素,3号位置后面的元素都要后移,删除一个元素，其后的元素都要往前移。但是使用LinkedList就不一样了，只要
把指针的指向改变一下就可以了。
所以说对于频繁的插入删除操作建议选择LinkedList


Set接口实现类：
HashSet(主要实现类)、LinkedHashSet

1、Set的无序性指的是元素在底层存储的顺序是无序的。而且无序性不等于随机性
2、不可重复性：当向Set中添加进相同元素的时候,后面的那个不能添加进去。
说明：要求添加进Set中的元素所在的类,一定要重写equals()和hashcode()方法
进而保证Set中元素的不可重复性。

Set中的元素是怎么存储的呢？
使用哈希算法。
首先我们说Set里面的元素是不可重复的。也就是说如果我往集合里面添加一个对象，但是集合里面有了，这个对象
是添加不进去的。现在问题来了，我添加一个对象，我怎么就知道集合中有这个对象呢？很显然你要拿你新添加的对象
和集合中的对象比较一下吧，如果一样就不让你添加进去。这时候就要求你添加的对象要重写equals()方法。不然它比较
的就是Object里面的equals()方法，Object里面的equals()方法比较的是地址值肯定不一样。这时候问题又来了，你添加
一个对象是不是要和集合里面所有的对象都比较一下,看有没有一样的，假如集合里面有10000个对象，你要比较一万次
才行，这样效率太低不行。所以我们采用算哈希值的方式。我向集合中添加一个元素的时候先计算下他的哈希值，根据
哈希值把它存储到内存中的相应位置，假设我现在添加一个对象计算出的哈希值和集合中的对象一样，这时候说明这两
个对象可能一样，现在我再用equals()方法去比较一下这两个对象。

LinkedHashSet:
你遍历集合的时候,遍历出来数据的顺序是和你添加进集合的顺序是一样的。(注意：但这并不能说明Set集合是有序的)
Set集合一个一个存放到内存中位置是无序的,LinkedHashSet只是使用链表维护了一个添加进集合的顺序,导致当我们遍历
LinkedHashSet集合元素时,是按照添加进去的顺序遍历的。
比如说我现在往集合里面存入第一个对象,这个对象可能会被放在三号位置，然后这个对象会有一个前面索引和后面
索引，现在存入第二个对象，这个对象可能被放在五号位置，这个对象也有个前面索引和后面索引，现在我第一个对象
的后面索引就通过指针指向第二个对象的前面索引，第二个对象的后面索引就指向第三个对象的前面索引，以此类推。
这样虽然存储的位置是无序的,但通过指针我维护了一个添加的顺序，导致我遍历的时候就按照这个添加的顺序遍历。

LinkedHashSet的特点：
1、LinkedHashSet是HashSet的子类。
2、LinkedHashSet根据元素的hashcode值来决定元素的存储位置,但它同时使用链表来维护元素的次序,这使得元素看起来
会像按照插入的顺序保存。
3、LinkedHashSet的插入的性能略低于HashSet,因为它在插入的同时还要维护链表的指向关系。但是在迭代的时候有很好
的性能。

TreeSet:
关于TreeSet的一个示例代码：
@Test
public void testTreeSet(){
	Set set = new TreeSet();
	set.add("aa");
	set.add("bb");
	set.add(123);
}
上面的代码如果我一运行,会报类型转换异常。原因是我前面两个添加的是String类型的，后面添加的是Integer类型的。

示例代码二：
@Test
public void testTreeSet(){
	Set set = new TreeSet();
	set.add("aa");
	set.add("ee");
	set.add("bb");
	set.add("dd");
	//遍历
	Iterator iterator = set.iterator();
	while(iterator.hasNext()){
		System.out.println(iterator.next());
	}
}
遍历出来的结果是aa bb ee dd跟添加的顺序有点不一样。其实遍历出来的顺序是按照26个字母的顺序。原因是String里面
默认是按照26个字母的排序来排的。

示例代码三：
@Test
public void testTreeSet(){
	Set set = new TreeSet();
	set.add(new Person(1001, "AA"));
	set.add(new Person(1002, "BB"));
	set.add(new Person(1003, "BB"));
	//遍历
	Iterator iterator = set.iterator();
	while(iterator.hasNext()){
		System.out.println(iterator.next());
	}
}
Person是一个自定义的类,上面的代码一运行就会报类型转换错误。而且错误指向3089行。那为什么我上面添加String
类型的时候没有报错呢？原因是String里面已经实现了Comparable接口而且重写了接口里面的抽象方法。而我这里往集合里面
添加的Person类实现Comparable接口和重写它里面的抽象方法。我们是在这个抽象方法里面去描述我添加进集合的元素
遍历的时候是按照什么顺序遍历。你没有实现这个接口和重写里面的抽象方法，你要是把元素添加进去后，它就不知道
按照什么顺序去遍历它，所以你要是自定义的类没有实现Comparable接口和重写这个接口里面的抽象方法它就不让你把
这个对象添加进集合里面报类型转换异常。

Person类里面重写的compareTo方法：
public int compareTo(Object o) {
		if(o instanceof Person){   //首先看传进来的这个参数如果是Person类型的
			Person p = (Person)o;  //强转成Person类型
			return this.name.compareTo(p.name);//this代表当前对象,当前对象的name性是String类型的,Sting类型重写了compareTo方法,这样就代表按照String里面默认的排序来排
		}
		return 0;
}
在这里说一下instanceof:
if(o instanceof Person)意思是o这个引用指向的那个对象是不是Person本类及Person子类类型的对象。
如果是的就返回true


TreeSet的定制排序：
示例代码：
@Test
public void testSet2(){
	//1、创建一个实现comparator接口的类对象
	Comparator com = new Comparator() {
		@Override
		public int compare(Object o1, Object o2) {
			if(o1 instanceof Customer && o2 instanceof Customer){
				Customer c1 = (Customer)o1;
				Customer c2 = (Customer)o2;
				return c1.getId().compareTo(c2.getId());
			}
			return 0;
		}
	};
	//2、将此对象作为一个形参传递给TreeSet的构造器中
	TreeSet set = new TreeSet(com);
	//3、向TreeSet中添加Comparator接口中compare方法中涉及的类的对象
	set.add(new Customer(1001, "AA"));
	set.add(new Customer(1002, "BB"));
	set.add(new Customer(1004, "CC"));
	Iterator iterator = set.iterator();
	while(iterator.hasNext()){
		System.out.println(iterator.next());
	}
}

定制排序和自然排序怎么选择？
自然排序需要在自定义类中实现Comparable接口和重写compareTo方法。如果你这个类不能修改,你就可以选择使用定制
排序。

TreeSet的特点：
1、向TreeSet中添加的元素必须是同一个类的，否则会报类型转化异常。
2、可以按照添加进集合中元素的指定顺序遍历。像String、包装类等默认是按照从小到大的顺序遍历。
3、当向TreeSet中添加自定义类的对象时,有两种排序方法：①自然排序②定制排序
4、自然排序：要求自定义类实现java.lang.Comparable接口并重写其compareTo(Object obj)方法,在这个方法中指明
按照自定义类的哪个属性排序。
5、向TreeSet中添加元素的时候,首先按照compareTo()进行比较,一旦返回0,虽然仅是两个对象的此属性相同,但是程序
会认为此属性是相同的，进而最后一个对象就不能添加进来。


Map接口：
Map与Collection是并列存在的。
Map中的Key和value都可以是任何引用类型的数据。
Map中的key是用Set来存放的,不允许重复。
常用String类做文件Map的键。

注：Map集合中所有的key构成一个keySet,因为key是用Set来存的,要求key是不能重复的。Map集合中不是一个个key-value嘛
我们把一个key-value叫做一个Entry

向HashMap中添加元素时，会调用key所在类的equals方法，判断两个key是否相同，所以这个时候就要求你这个key所在
的类要重写equals()方法,String已经重写过equals()方法了。如果两个key相同,则只能添加进后添加的那个元素。

Map中的方法:
* Object put(Object key,Object value):向Map中添加一个元素
* Object remove(Object key)按照指定的key删除此key-value
* void putAll(Map m)
* void clear():清空
* Object get(Object key)获取指定key的value值，若无，则返回null
* boolean containsKey(Object key)
* int size():返回集合的长度
* boolean isEmpy()

如何去遍历一个Map:
@Test
public void test2(){
	Map map = new HashMap();
	map.put("AA", 123);
	map.put("CC", 234);
	map.put("BB", 456);
	
	//遍历key集
	Set keySet = map.keySet();
	for(Object obj : keySet){
		System.out.println(obj);
	}
	
	//遍历value集
	Collection values = map.values();
	for(Object obj : values){
		System.out.println(obj);
	}
	
	//遍历key-value对
	//方法一：遍历key集得到一个个key然后通过key去得到value
	Set keySet1 = map.keySet();
	for(Object obj : keySet1){
		System.out.println(obj+"---"+map.get(obj));
	}
	//方法二：
	Set entrySet = map.entrySet();    //这个entrySet里面存放着key和value但现在这个entrySet是Set类型的
	for(Object obj : entrySet){
		Map.Entry maps = (Map.Entry)obj;//因为这个obj是一个Entry，所以我给他强转过来.
		System.out.println(maps.getKey()+"---"+maps.getValue());
	}
}

去读项目里面的properties属性文件的方法：
	@Test
	public void test3() throws Exception{
		Properties pro = new Properties();
		pro.load(new FileInputStream(new File("jdbc.properties")));
		String property = pro.getProperty("username");
		System.out.println(property);
}

--------------------------------------------------------------------------------------------------------
																								数组
---------------------------------------------------------------------------------------------------------																					--------------------------------------------------------------
一维数组的初始化：
--动态初始化：
int[]scores = new int[3];			
scores[0] = 80;              在这里scores[1]没有赋值,那就默认为0
scores[2] = 70;
结论：对于byte short int long而言，创建数组以后，默认值为0
对于float double而言，创建数组以后默认值为0.0
对于char而言，创建数组后默认值为空格
对于boolean而言，创建数组以后默认是false
对于引用类型的变量构成的数组，默认初始化值为null
---------------------------------------------------------------------------------------------------------
																				Java Web部分
--------------------------------------------------------------------------------------------------------
Servlet简介：
Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。 Servlet容器负责Servlet和客户端的通信以及
调用Servlet的方法。
Servlet可完成如下功能：
--创建并返回基于客户请求的动态HTML页面
--创建可嵌入到现有HTML页面中的部分HTML页面
--与其他服务器资源(如数据库)进行通信
其实Servlet本质上讲就是一个Java类，只不过它是部署运行在Servlet容器里面

在web.xml中配置servlet:
<servlet>
		<servlet-name>helloServlet</servlet-name>
		<servlet-class>com.iflytek.java.test.HelloServlet</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name>helloServlet</servlet-name>     这里的servletname和上面的名字必须要一样
	<url-pattern>/hello</url-pattern>
</servlet-mapping>
解释一下上面的这段配置：
我用浏览器要去访问这个servlet，我是根据这个url-pattern来访问的。浏览器中写的url-pattern如果和这里的一样
就根据这个url-pattern去找对应的servlet-name,因为这个映射里面的servlet-name要求必须和servlet里面的的servlet-name
一样所以找到servlet里面的那个servlet-name进而就找到servlet-class就能把这个servlet给加载好。


现在这里有个HelloServlet的的代码简单分析一下：
public class HelloServlet implements Servlet {

	@Override
	public void destroy() {
		System.out.println("destroy");
	}

	@Override
	public ServletConfig getServletConfig() {
		System.out.println("getServletConfig");
		return null;
	}

	@Override
	public String getServletInfo() {
		System.out.println("getServletInfo()");
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init");
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1)
			throws ServletException, IOException {
		System.out.println("service");
	}
	
	public HelloServlet() {
		System.out.println("你好我是构造器");
	}
}
分析上面这段代码：
以前我们创建一个对象，都要在main方法里面new一个这个对象调用其构造方法。而现在我只要一启动tomcat服务器
把项目放在tomcat服务器下面跑，当我第一次访问的时候就会调用它的构造方法创建实例，而我并没有去new，这个过程
就是tomcat服务器帮我们干的。在这里tomcat服务器就是Servlet容器，Servlet容器管理整个servlet的生命周期，调用
生命周期方法。每次运行都会调service方法，而且当服务器关闭的时候还会调用destroy方法。

Servlet的生命周期方法：
1)构造方法：只有第一次请求访问Servlet的时候，调用构造器，创建servlet的实例，第二次请求的时候就不会再调用了。
这说明servlet是单例的，跟单例模式懒汉式有点像。只创建一个对象，既然我们说是单例的跟懒汉式有点像，那么它也有
线程安全问题，所以我们不建议在servlet里面写一个全局变量，然后每一次在service方法里面去改变它的值，这样是有
问题的，因为牵扯到共享资源就会可能存在线程安全问题。
2)init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前servlet。初始化是在构造器里面初始化，
但是这个init方法能传一个ServletConfig参数可以对servlet进行初始化
3)service方法：可以被多次调用，每次请求都会调用service方法。
4)destroy方法：只被调用一次，在当前servlet所在的web应用被卸载前调用， 用于释放当前Servlet所占用的资源。

通过上面的分析我们知道，构造方法和init方法是在第一次被请求的时候调用，比如说我把项目的url在浏览器地址栏
都写好然后向浏览器发送请求，这时候就会调构造方法创建实例，创建完实例后马上调init方法。
那我有没有一个可能就是我在当前web应用被加载的时候就创建实例调用init方法呢？
答：在web.xml里面配置<load-on-startup>1</load-on-startup>
<servlet>
		<servlet-name>helloServlet</servlet-name>
		<servlet-class>com.iflytek.java.test.HelloServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
</servlet>
这个<load-on-startup>1</load-on-startup>可以指定servlet被创建的时机
这个值如果是负数，当前web应用加载被Servlet容器加载的时候就不创建实例和调init方法而是在第一次请求的时候创建实例调用init方法
这个值如果是正数或0就在当前web应用被Servlet容器加载的时候创建实例和调用init方法，而且值越小，越先被创建。

Servlet容器响应客户请求的过程：
①Servlet引擎检查是否已经创建了该servlet实例对象，如果创建了直接执行④否则执行⑤
②创建servlet的实例对象，调用servlet的构造方法
③调用Servlet实例对象的init方法
④创建一个用于封装请求的ServletRequest对象和一个代表响应信息servletResponse对象然后调用service方法
并将请求对象和响应对象作为参数传递进去
⑤web应用程序被停止或重新启动之间，会调用Servlet的destroy方法。

Servlet映射的细节：
1、同一个servlet可以被映射到多个url上
例如：
<servlet>
		<servlet-name>helloServlet</servlet-name>
		<servlet-class>com.iflytek.java.test.HelloServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>helloServlet</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
	<servlet-mapping>
		<servlet-name>helloServlet</servlet-name>
		<url-pattern>/hello2</url-pattern>
</servlet-mapping>
现在我通过hello和hello2这两个url都能去访问到helloServlet这个应用程序

2、在servlet映射的url中可以使用*通配符，但是只能有两种固定的格式：
一种格式是"*.扩展名"，另一种格式是以正斜杠（/）开头，并以"/*"结尾

说一说init方法里面传的参数ServletConfig:
这个ServletConfig对象封装了Servlet的配置信息，并且可以获取ServletContext对象
1)可以通过它获取servlet的初始化参数
要获取这个初始化参数,首先我们来看一下怎么配置servlet的初始化参数：
<servlet>
	<servlet-name>helloServlet</servlet-name>
	<servlet-class>com.iflytek.java.test.HelloServlet</servlet-class>
	<init-param>
		<param-name>user</param-name>
		<param-value>root</param-value>
	</init-param>
	<init-param>
		<param-name>password</param-name>
		<param-value>123</param-value>
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>
配置好了以后下面说如何获取初始化参数：
  >>getInitParameter(String name)获取指定参数名的初始化参数的值
  >>getInitParameterNames():获取参数名组成的Enumeration对象，就是把所有的参数名都获取到了

public void init(ServletConfig servletConfig) throws ServletException {
		String user = servletConfig.getInitParameter("user");
		System.out.println(user);       //打印结果是root
		Enumeration<String> names = servletConfig.getInitParameterNames();
		while(names.hasMoreElements()){
			System.out.println("**"+names.nextElement());       遍历这个对象得到所有的参数名
		}
}
ServletConfig这个接口里面还有一个就是getServletContext()方法

ServletContext接口：
Servlet引擎为每个WEB应用程序都创建一个对应的ServletContext对象，由于一个WEB应用程序中所有的Servlet都共享
一个ServletContext对象，所以ServletContext对象被称为application对象(Web应用程序对象)
1)可以有ServletConfig获取
2)该对象代表当前WEB应用：可以认为ServletContext是当前WEB应用的大管家，可以从中获取到当前WEB应用的各个方面的信息。
①获取当前web应用的初始化参数
下面我先配置一下，再去获取。
配置代码（在web.xml）：
<!-- 配置当前web应用的初始化参数 -->
<context-param>
		<param-name>driverClass</param-name>
		<param-value>com.mysql.jdbc.Driver</param-value>
</context-param>
<context-param>
		<param-name>jdbcUrl</param-name>
		<param-value>jdbc:mysql://localhost:8080/database</param-value>
</context-param>
你如果是多个参数肯定要写多个<context-param>你不可能是在一个里面写多个参数
获取当前WEB应用初始化参数代码如下：
public void init(ServletConfig servletConfig) throws ServletException {
		ServletContext servletContext = servletConfig.getServletContext();
		String driverClass = servletContext.getInitParameter("driverClass");
		System.out.println("---"+driverClass);
		
		Enumeration<String> names2 = servletContext.getInitParameterNames();
		while(names2.hasMoreElements()){
			System.out.println("----"+names2.nextElement());
		}
}
其实方法跟上面获取servlet的初始化参数方法差不多也是两个方法：
  >>getInitParameter(String name)
  >>getInitParameterNames()

那我获取当前Web应用的初始化参数和获取servlet的初始化参数有什么区别吗？
servlet初始化参数是设置在servlet里面的是局部的只有当前servlet能获取到，而Web应用的初始化参数是全局，所有
的servlet都能获取到。比如说你有一个初始化参数，这个初始化参数所有的servlet都要用的话，这时你就要给他设置
成全局的。

②获取当前WEB应用的某一个文件的绝对路径：
>>getRealPath(String path)                  这个比如说在进行文件上传和下载的时候我需要知道绝对路径是什么
代码示例：
public void init(ServletConfig servletConfig) throws ServletException {
		ServletContext servletContext = servletConfig.getServletContext();
		String realPath = servletContext.getRealPath("/note.txt");
		System.out.println(realPath);
}
注：需要注意的是这里获取到的绝对路径是你这个文件发布到服务器上的一个绝对路径，而不是这个文件在发布之前
的那个物理路径。

③获取当前WEB应用的名称：
>>getContextPath()            
代码示例：
public void init(ServletConfig servletConfig) throws ServletException {
		ServletContext servletContext = servletConfig.getServletContext();
		String contextPath = servletContext.getContextPath();
		System.out.println(contextPath);
}

④获取当前WEB应用的某一个文件对应的输入流：
>>getResourceAsStream(String name)
代码示例：
public void init(ServletConfig servletConfig) throws ServletException {
		ServletContext servletContext = servletConfig.getServletContext();
		try {
			ClassLoader classLoader = getClass().getClassLoader();
			InputStream is = classLoader.getResourceAsStream("jdbc.properties");
			System.out.println("1、"+is);   //这个是使用类加载器的方式
			InputStream is2 = servletContext.getResourceAsStream("/WEB-INF/classes/jdbc.properties");
			System.out.println("2、"+is2);
		} catch (Exception e) {
			e.printStackTrace();
		}
}


HTTP协议简介：
Web浏览器与Web服务器之间一问一答的交互过程必须遵循一定的规则，这个规则就是HTTP协议。

http的会话方式：
分为四个步骤：
建立连接、发送请求信息、回送响应信息、关闭连接


现在我们来研究研究Servlet生命周期中的service方法：
我们知道每次发送请求的时候都会调用service方法。
如何在servlet中获取请求信息：
1).servlet中的service方法用于应答请求：因为每次请求都会调用service方法
public void service(ServletRequest request, ServletResponse response)
			throws ServletException, IOException {
}
ServletRequest:封装了请求信息，可以从中获取到任何的请求信息。
ServletResponse:封装了响应信息，如果想给用户什么响应，均可以使用该接口的方法实现
上面的这两个接口的实现类都是服务器给予实现的，并在服务器调用service方法时传入。
比如：
ServletRequest它只是一个接口，里面定义的很多方法，实现是由tomcat服务器来给我实现的。
现在假如我服务器换了不用tomcat了，那么实现就有相应的你使用的服务器来实现。

2).ServletRequest:
①获取请求参数：
		>>String getParameter(String name)根据请求参数的名字，返回参数值
		如果请求参数有多个值,例如：checkbox多选你要带多个值过去，如果你还用这个方法去获取那么只能获取到多选的第一个值。这时候就要用下面的方法
		>>String[] getParameterValues(String name)根据请求参数的名字，返回请求参数对应的字符串数组   适用于请求参数有很多值
		>>Map getParameterMap();
		>>Enumeration getParameterNames()返回参数名对应的Enumeration对象   类似于ServletConfig或ServletContext的getInitParameterNames()方法
		

注：
HttpServletRequest httpServletRequest = (HttpServletRequest)request;
这里为什么可以这么强转？以及强转有什么目的？
因为我们的请求一般都是http请求，而这个request的类型是ServletRequest,所以我们把它强转一下是没有问题的。
至于强转的目的,HttpServletRequest是ServletRequest的子接口它里面有很多http相关的方法,所以我们强转一下就可以
用里面的方法了。

servletResponse:
>>getWriter():返回PrintWriter对象，调用该对象的print()方法，将把print()中的参数直接打印到客户的浏览器上。
>>response.setContentType("application/vnd.ms-word")设置响应的内容类型。


JSP:
JSP是简化servlet编写的一种技术，它将Java代码和html混合在同一个文件中编写，只对网页中要动态产生的内容采用
Java代码来编写。而对固定不变的静态内容采用普遍静态HTML页面的方式编写。
可以在页面中嵌Java代码，然后经过Servlet解释执行这就是JSP。

jsp运行原理：JSP本质上就是一个servlet
WEB容器(Servlet引擎)接收到以.jsp为扩展名的url的访问请求的时候，它将把该访问请求交给JSP引擎去
处理。
每个jsp页面在第一次被访问的时候，JSP引擎将它翻译成一个Servlet源程序，接着再把这个Servlet源程序
编译成Servlet的class类文件，然后再由WEB容器(Servlet引擎)像调用普通Servlet程序一样的方式来装载和
解释执行这个由JSP页面翻译成的Servlet程序。

JSP页面的隐含对象：
你在jsp页面不是可以通过使用<% %>来嵌入一段java代码嘛，而在这<% %>里面我就可以使用
request、response、pageContext、session、application、config、out、page、exception
这几个隐含对象。

隐含对象是什么意思？
一般我先要声明一个对象，才能调用这个对象的方法。隐含对象就是我可以不用声明就来调用这个对象的
方法。

下面来分别说说这几个隐含对象：
request: 它是HttpServletRequest的一个对象。
response: 它是HttpServletResponse的一个对象(在jsp页面几乎不会调用response的任何方法)
pageContext:页面的上下文,是PageContext的一个对象，可以从该对象中获取到其他8个隐含对象，而且我
可以从这个对象中获取到当前页面的几乎一切信息。
session:代表浏览器和服务器的一次会话,是HttpSession的一个对象。
application:代表当前WEB应用,是ServletContext的一个对象。
config:是当前jsp对应的servlet的ServletConfig对象(开发的时候几乎不用)。
out:JspWriter对象,调用out.println()可以直接把字符串打印到浏览器上。
page:开发的时候几乎不用。
exception:只有在jsp页面的上面声明了page指令的isErrorPage="true"才可以使用。

JSP表达式：
提供一个将java变量或表达式的计算结果输出到客户端的简化方式，它将要输出的变量或表达式直接封装在
<%= %>之中。
例如：
<% 
	Date date = new Date()
%>
<%= data %>    直接就可以输出日期


和属性相关的方法：
--Object getAttribute(String name):获取指定属性
--Enumeratioin getAttributeNames():获取所有属性的名字组成的Enumeration对象
--removeAttribute(String name):移除指定属性
--void setAttribute(String name,Object o):设置属性

那么哪些隐含对象有上面的方法呢？
pageContext、request、session、application 这些方法都有上面的四个方法。
这四个对象也称为域对象。

下面是代码说明：
我新建一个jsp文件叫attr_1.jsp
<body>

	<%
		pageContext.setAttribute("pageContextattr", "pageContextVal");
		request.setAttribute("requestattr", "requestVal");									我把这些属性值都放到这些域对象里面
		session.setAttribute("sessionattr", "sessionVal");
		application.setAttribute("applicationattr", "applicationVal");
	%>
	
	pageContextattr:<%= pageContext.getAttribute("pageContextattr") %>
	<br>
	requestattr:<%= request.getAttribute("requestattr") %>
	<br>																																上一步我是在当前页面把属性值set到域对象里面，然后我在当前页面取，肯定是可以的。
	sessionattr:<%=session.getAttribute("sessionattr") %>
	<br>
	applicationattr:<%=application.getAttribute("applicationattr") %>
	
	<a href="attr_2.jsp">To Attr2 page</a>       这个超链接用于连接到attr_2.jsp这个文件
</body>

下面我再新建一个jsp文件叫attr_2.jsp     项目一启动我在attr_1.jsp里面写一个超链接让它跳到attr_2.jsp 里面来，然后看这四个域对象谁能拿到值，谁不能拿到值。 
代码部分：
<body>
	
	pageContextattr:<%= pageContext.getAttribute("pageContextattr") %>
	<br>
	requestattr:<%= request.getAttribute("requestattr") %>
	<br>
	sessionattr:<%=session.getAttribute("sessionattr") %>
	<br>
	applicationattr:<%=application.getAttribute("applicationattr") %>

</body>
这时候我们就会发现pageContextattr和requestattr这两个拿到的值为空，下面两个域对象还是可以拿到值的

说一下这四个域对象的作用范围：
pageContext:作用范围仅限于当前jsp页面
request:作用范围仅限于同一个请求。
session:作用范围仅限于一次会话。什么叫一次会话？就是浏览器打开直到关闭叫一次会话(前提是会话不失效,比如说会话有个作用时间,超过那个作用时间会话就失效了)
application:作用范围限于当前WEB应用。作用范围最大，在一处设置属性，在其他各处比如servlet、jsp都能取到

下面解释一下为什么pageContext和request这两个域对象在attr_1.jsp页面没有拿到值：
因为pageContext作用范围仅限于当前jsp页面，你是在attr_1.jsp设置的值，所以换个页面肯定就拿不到值了。
而request作用范围仅限于同一个请求，你在attr_1.jsp里面写了一个超链接到attr_2.jsp，一点击就变成另外一个请求了，不是同一个请求肯定就拿不到值了。


请求的重定向和转发：
二者的本质区别就是：
请求的转发只发出了一次请求，而重定向发出了两次请求。
比如A发一个请求给B,B将这个请求转发给了C那么地址栏的地址还是B的地址,你看开发者工具network也只有一次请求。
如果B将这个请求重定向到C那么地址栏的地址就是C的地址,你看开发者工具network会发现有两个请求。

具体说明：
①：
请求的转发：地址栏是初次发出的请求地址。
请求的重定向：地址栏不是初次发出的请求地址,地址栏是最后响应的那个地址。

②：
请求转发：在最终的Servlet中,由于是同一个请求,request对象和中转的那个request是同一个对象。
请求的重定向:在最终的Servlet中,由于不是同一个请求,request对象和中转的那个request不是同一个对象。

③：
请求转发：只能转发给当前WEB应用的资源。
请求重定向：可以重定向到任何资源。

④：
请求转发： / 代表当前WEB应用的根目录,   这也就能解释清楚③转发只能转发给当前WEB应用的资源,因为转发我们一般在路径前写上 /  然后他肯定就会在当前WEB应用下面去找对应的资源。
请求的重定向： / 代表的是当前WEB站点的根目录。

解释一下④：
<%
		request.getRequestDispatcher("/c.jsp").forward(request, response);
		response.sendRedirect("/c.jsp");
%>
我当前项目的名称叫做javaweb,如果是转发的方式它是怎么去找c.jsp呢？
因为转发的 / 代表当前WEB应用的根目录,所以我就会去javaweb下面去找这个c.jsp这个资源,对应浏览器地址栏
就是localhost:8080/javaweb/c.jsp
而如果是重定向我怎么去找c.jsp呢？
因为重定向的 / 代表当前WEB站点的根目录,什么是当前WEB站点的根目录？
简单点说就是http://localhost:8080  叫做当前WEB站点的根目录。如果你写response.sendRedirect("/c.jsp")
它就会去http://localhost:8080下面去找c.jsp这个文件,对应浏览器地址栏就是http://localhost:8080/c.jsp


JSP指令：
jsp指令是为jsp引擎而设计的,他们并不产生任何可见的输出,而只是告诉引擎如何处理jsp页面中的其余部分。
例如：
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>   这就是jsp指令
    
page指令：
page指令用于定义jsp页面的各种属性,无论page指令出现在jsp页面中的什么地方,它作用的都是整个jsp页面,
为了保证良好的编程习惯,page指令最好是放在整个jsp页面的起始位置。
<%@ page session="false" %>  page指令下面的一个属性        表示在当前jsp页面我不让你使用session这个隐含对象

<%@ page errorPage="/error.jsp" %>
指定了一个错误页面。如果在当前页面发生错误或者异常了,jsp引擎会自动的把error.jsp作为响应页面。

先在我们知道了error.jsp就是一个错误页面,那么我们可以在error.jsp的开头声明一下：
<%@ page isErrorPage="true" %>
这样我们在jsp页面就能使用exception这个隐含对象了
<%
String message = exception.getMessage();    得到异常信息     如果不声明isErrorPage="true"就不能使用exception这个隐含对象
%>
一般是一个页面出现异常了,我才让它跳到错误页面,一般我们不建议直接访问错误页面。
因为你直接访问它就上面的代码来说肯定就报空指针异常,因为你exception是空。

include指令：
include指令用于通知JSP引擎在翻译当前JSP页面时将其他文件的内容合并进当前JSP页面转换成的Servlet源文件
中,这种在源文件级别进行引入的方式称之为静态引入,当前JSP页面与静态引入的页面紧密结合为一个Servlet。
<%@ include file="b.jsp" %>
file属性的设置值必须是相对路径
例如,我写一个a.jsp页面
<%@ include file="b.jsp" %>
<body>
	<h3>AAA PAGE</h3>	
</body>
再写一个b.jsp页面
<body>
	<h3>BBB PAGE</h3>
</body>
我在a.jsp页面的头上写了一个<%@ include file="b.jsp" %>这个,这样b.jsp页面的内容就会全部包含进
a.jsp页面里面。


数据库连接池：
我们先说说应用程序直接获取数据库连接的缺点：
如果直接获取数据库连接,用户发一次请求就想数据库获得一次连接,而数据库创建一次连接通常需要消耗很大
的资源而且创建时间长。假设一个网站一天10万访问量那么数据库服务器就要创建10万次连接,极大的浪费数据库
资源,并且容易造成数据库服务器内存溢出、宕机。

所以我们就考虑使用数据库连接池来解决这个问题,数据库连接池负责分配、管理和释放数据库连接,它允许应用
程序重复使用一个现有的数据库连接,而不是重新建立一个连接。

数据库连接池在初始化时将创建一定数量的数据库连接到连接池中,这些数据库连接的数量由最小数据库连接数
来设定,无论这些数据库连接是否被使用,连接池都将保证至少拥有这么多的连接数量,连接池的最大连接数量
限定了这个连接池能占有的最大连接数量,当应用程序向连接池的请求的连接数超过最大连接数量时,这些请求将
被加入到等待的队列中。

数据库连接池的最小连接数和最大连接数的设置要考虑以下三点：
1、最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量
数据库连接资源被浪费。
2、最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到
等待队列中,这会影响以后的数据库操作。
3、如果最小连接数和最大连接数相差很大：那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价
于建立一个新的数据库连接。不过这些大于最小连接数的数据库连接使用完不会被马上释放,它将被放到连接池中
等待重复使用或是空间超时后被释放。

既然连接池这么好,你就可以写一个连接池。
编写连接池时需要实现java.sql.DataSource接口

现在很多WEB服务器(Weblogic, WebSphere, Tomcat)都提供了DataSoruce的实现，即连接池的实现。
通常我们把DataSource的实现，按其英文含义称之为数据源，数据源中都包含了数据库连接池的实现。

也有一些开源组织提供了数据源的独立实现：
---DBCP 数据库连接池
---C3P0 数据库连接池
在使用了数据库连接池之后，在项目的实际开发中就不需要编写连接数据库的代码了，直接从数据源获得数据库的连接。

下面说明部分代码的意思：
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>  
    <named-config name="mvcapp">     这里的name有点重要
    	<property name="user">root</property>
    	<property name="password">123</property>
    	<property name="driverClass">com.mysql.jdbc.Driver</property>
    	<property name="jdbcUrl">jdbc:mysql://localhost:3306/javaweb</property>
    
        <property name="acquireIncrement">5</property><!-- 连接池在无空闲连接可用时一次性创建的新数据库连接数 -->  
        <property name="initialPoolSize">10</property><!-- 连接池初始化时创建的连接数 -->  
        <property name="minPoolSize">10</property>  
        <property name="maxPoolSize">50</property><!-- intergalactoApp adopts a different approach to configuring statement caching -->  
        <property name="maxStatements">20</property> <!-- 连接池为数据源缓存的PreparedStatement的总数。 -->
        <property name="maxStatementsPerConnection">5</property> <!-- 连接池为数据源单个Connection缓存的PreparedStatement数，这个配置比maxStatements更有意义，因为它缓存的服务对象是单个数据连接，如果设置的好，肯定是可以提高性能的。为0的时候不缓存 --> 
    </named-config>  
</c3p0-config>  
以上是我在c3p0-config.xml中的代码。
public class JdbcUtils {
	
	private static DataSource dataSource;
	static{
		dataSource = new ComboPooledDataSource("mvcapp");
	}
}
c3p0有两种创建方式，第一是：无参的，直接new，然后set它的四要素，如：setDriverClass(),setJdbcUrl()等；
第二种就是用带参的构造器,new ComboPooledDataSource("mvcapp"）它的参数就是你配置文件中起的名字，
这种情况下就不需要你自己去读配置文件,它会根据这个名字去配置文件里面找。


多个请求使用同一个Servlet的两种方法：
参看博客链接：
http://www.cnblogs.com/HiJacky/p/5513596.html
http://blog.csdn.net/qq_25201665/article/details/52037607
或者看javaweb佟刚视频教程mvc案例上里面和博客里讲得一样。


会话和会话状态：
WEB应用中的会话是指一个客户端浏览器与WEB服务器之间连续发生的一系列请求和响应过程。
WEB应用的会话状态是指WEB服务器与浏览器在会话过程中产生的状态信息，借助会话状态
WEB服务器能够把属于同一会话中的一系列请求和响应过程关联起来。

Cookie机制：
Cookie是浏览器在访问WEB服务器的某个资源时,由WEB服务器在HTTP响应消息头中附带传送给浏览器的
一个小文本文件。
一旦WEB浏览器保存了某个Cookie,那么它在以后每次访问该WEB服务器时,都会在HTTP请求头中将这个Cookie
回传给WEB服务器。(就是说如果你浏览器没有禁用Cookie的话,下次再请求的话就会把这个Cookie给传回来)
说的通俗一点就是我浏览器第一次访问WEB服务器的时候是没有Cookie的,然后WEB服务器给浏览器一个响应
通过set-cookie的方式给浏览器一个Cookie,等到浏览器下次再访问WEB服务器的时候就会把这个Cookie通过
HTTP请求头带上回送给WEB服务器。

Servlet程序中使用Cookie:
HttpServletResponse接口中定义了一个addCookie方法,它用于在发送给浏览器的HTTP响应消息中增加一个
set-cookie响应头字段。
HttpServletRequest接口中定义了一个getCookies方法,它用于从HTTP请求消息的Cookie请求头字段中读取所有
的Cookie项。
例如：
<%	
		//1.获取Cookie
		Cookie[]cookies = request.getCookies();    这个方法得到的是一个Cookie数组
		if(cookies != null && cookies.length > 1){
			for(Cookie cookie : cookies){
				out.print(cookie.getName()+":"+cookie.getValue());
				out.print("<br/>");
			}
		}else{
			 //创建一个Cookie对象
			 Cookie cookie = new Cookie("name","Jimmy");
			 //调用response的一个方法把Cookie传给客户端
			 response.addCookie(cookie);
		}
%>

如果创建了一个Cookie(Web服务器创建的),并将它发送到浏览器,默认情况下它是一个会话级别的cookie,存储在
浏览器的内存中,用户退出浏览器后被删除。
上面这句话的意思就是,你浏览器第一次发一个请求到WEB服务器,打开F12开发者工具在network的请求头里是
看不到cookie的但是在响应头里面是能看到Set-Cookie的,当你再次访问的时候在请求头里面就能看到cookie了
但是这个cookie它是一个会话级别的cookie,你浏览器一关,下次再来访问的时候network的请求头里面就又没
cookie了。

****若希望浏览器将该Cookie存储在磁盘上,则需要使用maxAge,并给出一个以秒为单位的时间。
如果你将maxAge设为0则是命令浏览器删除该Cookie。
Cookie cookie = new Cookie("name","Jimmy");
cookie.setMaxAge(30);

会话Cookie和持久Cookie的区别：
如果不设置过期时间,则表示这个Cookie生命周期为浏览器会话期间,只要关闭浏览器窗口,cookie就消失了。
这种生命周期为浏览器会话期间的cookie称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。
如果设置了过期时间,浏览器就会把cookie保存在硬盘上,关闭后再次打开浏览器,这些cookie依然有效知道超过
设定的过期时间。

再来说说这个setMaxAge()方法：
设置Cookie的最大时效,以秒为单位,参数若为0,表示立即删除该Cookie。参数若为负数,表示不存储该Cookie。
参数若为正数,表示该Cookie的存储时间。 

下面就用Cookie来完成一个小案例：
一般我们登录的时候都会要求填写用户名和密码,但是你记住以后下次就可以不用填写用户名和密码,比如说
新浪微博可以直接进去,下面我想实现的就是不需要填写用户名和密码等信息,可以自动登录到系统。
现在我有两个jsp页面,一个login.jsp和hello.jsp
如果在hello.jsp中可以获取到login.jsp提交过来的loginName请求参数,则打印出欢迎信息,并把登录信息存储到
Cookie中,并设置Cookie的最大时效为30秒。
你直接访问hello.jsp,如果Cookie中存在用户信息,从Cookie中读取用户信息,并打印欢迎。
你直接访问hello.jsp,如果既没有login.jsp提交过来的请求参数也没有Cookie,则重定向到login.jsp去登录
代码：
login.jsp:
	<form action="hello.jsp" method="post">
		name:<input type="text" name="name">
		<input type="submit" value="提交">
	</form>
	
hello.jsp:
	<%
		String name = request.getParameter("name");
		if(name != null){
			out.print("welcome to"+name);
			Cookie cookie = new Cookie("name",name);
			cookie.setMaxAge(30);
			response.addCookie(cookie);
		}else{
			Cookie [] cookies = request.getCookies();
			if(cookies != null && cookies.length > 0){
				for(Cookie cookie :cookies){
					String cookieName = cookie.getName();
					if("name".equals(cookieName)){
						String val = cookie.getValue();
						out.print("welcom to"+val);
					}
				}
			}else{
				response.sendRedirect("login.jsp");
			}
		}
	
	%>

用Cookie完成的另一个小案例：
需求就是显示最近浏览的5本书
现在有两个jsp页面：
books.jsp和book.jsp
先来说说books.jsp:
这个页面用来显示最近浏览的5本书：
怎么获取？使用Cookie
1、获取所有的Cookie
2、从所有的Cookie中筛选出Book的Cookie:如果cookieName为shp_book开头的即符合条件
3、显示cookieValue

再来说说book.jsp:
把书的信息以Cookie的方式回传给浏览器,删除一个Cookie
1、确定要删除的Cookie:是以shp_book开头的,Cookie的数量大于或等于5,且若从books.jsp页面传入的book
不在shp_book开头的Cookie中,则删除较早的那个Cookie(shp_book_数组的第一个Cookie),若在其中,若在其中
则删除该Cookie
2、把books.jsp传入的book作为一个Cookie返回。


cookie的作用范围：
可以作用于当前目录和当前目录的子目录,但不能作用于当前目录的上一级目录
但是我们可以通过使用cookie.setPath(request.getContextPath())来指定Cookie的作用范围


session:
session在web开发环境下的语意又有了新的扩展，它的含义是指一类用来在客户端与服务器端之间保持状态的
解决方案。

跟踪用户的状态信息有两种方案,一种是Cookie一种是session。
Cookie是在客户端保存那个信息,在每次发请求的时候把那个值回传给服务器以达到来看一下是不是同一个浏览器
发出的请求信息这样的一个目的。

session机制：
session机制采用的是在服务器端保持HTTP状态信息的方案。

假设你客户端给服务器端发送了一个请求,这个请求如果是第一次发送没有带任何标识,服务器端没办法匹配到
一个session给你这个请求,只能新创建一个session对象,这个过程是浏览器向服务器端发一个请求,等到服务器端
给你这个浏览器响应的时候,它会以Cookie的方法把刚才创建的session对象的sessionID给你传回来,通过Set-Cookie
响应头的方式,这个Cookie的名叫JSSIONID,值是一个很长的字符串。这样就把响应给了浏览器。然而我们知道
这个Cookie的基本机制是,只要你客户端接收到了这个Cookie响应头,下次你再请求的时候就会把这个Cookie带着
回传给服务器。好，这样我们的目的就达到了。等到下次再请求的时候,我就会把这个Cookie带着,而这个Cookie里面
又有JSSIONID,我请求到服务器的时候就会根据这个JSSIONID去找当时创建的session就可以找到了。所以只要
我浏览器不关我这个Cookie就存在,就可以找到对应的session。


保存session id的几种方式：
---保存session id的方式可以采用cookie(这个在上面已经提到),这样在交互的过程中浏览器可以自动的按照
规则把这个标识发送给服务器。
---由于cookie可以被人为的禁用,必须有其他的机制以便在cookie被禁用时仍然能够把session id传递回服务器
经常采用的一种技术叫URL重写,就是把session id附加在URL路径的后面,附加的方式也有两种,一种是作为
URL路径的附加信息,另一种是作为查询字符串附加在URL后面。网络在整个交互过程中始终保持状态,就必须在
每个客户端可能请求的路径后面都包含这个session id。

HttpSession的生命周期：
1、什么时候创建HttpSession对象？
	1)是否浏览器访问服务器端的任何一个JSP或Servlet,服务器都会立即创建一个HttpSession对象呢？
不一定。若当前JSP是客户端访问的当前WEB应用的第一个资源,且JSP的page指令的session属性值为false,服务器就
不会为JSP创建一个HttpSession对象;若当前JSP不是客户端访问的当前WEB应用的第一个资源,且其他页面已经
创建一个HttpSession对象,则当前JSP页面会返回一个会话的HttpSession对象(这个session对象是从其他页面传过来的),
而不会创建一个新的HttpSession
对象。
	2)session="false"表示什么意思?
表示当前JSP页面禁用session隐含变量(并不是说当前页面就不能有session对象),你用session.XXX是点不出来的,但是我可以使用另一种方法使用session
如：
<%
HttpSession session = request.getSession(false);      就是说隐含变量我用不了了,但是我可以显示的去获取session对象
%>

2、
1)对于Servlet而言,有一点是和JSP页面时一样的,比如说我这个Servlet是从a页面连过来的,在当前这个Servlet
里面我能够获取到a页面传过来的session对象,那么这个Servlet就不会创建session对象。
2)若servlet是客户端访问的第一个WEB应用的资源,则只有调用了request.getSession()或request.getSession(true)
才会创建HttpSession对象。

3、在Servlet中如何获取HttpSession对象？
		>>>request.getSession(boolean create):
create为false,若没有和当前JSP页面关联的HttpSession对象,则返回null;若有,返回true
create为true,一定返回一个HttpSession对象。若没有和当前JSP页面关联的HttpSession对象,则服务器创建
一个新的HttpSession对象返回,若有,直接返回关联的。
		>>>request.getSession():等同于request.getSession(true)

4、什么时候销毁HttpSession对象？
①直接调用HttpSession对象的invalidate()方法
session.invalidate();
②服务器卸载了当前WEB应用
③超出HttpSession的过期时间
对于第三点,JSP页面的page指令的session属性值默认为true,就是说我浏览器一访问JSP页面就会给我创建一个
session对象(前面也说了若当前JSP是客户端访问的当前WEB应用的第一个资源,且JSP的page指令的session属性值为false,服务器就
不会为JSP创建一个HttpSession对象)现在JSP页面的page指令的session属性值默认为true,就是说我一访问
jsp页面就会给我创建session对象,现在如果我并发量特别大,有很多的session,而且这个session又可以无限
时间的保留,那么这样服务器的资源是不是就会被耗尽了,所以说session应该有一个过期时间。
session.setMaxInactiveInterval(5);     设置session的过期时间,以秒为单位
session.getMaxInactiveInterval();				获取session的过期时间,默认过期时间是1800秒
除了想上面的那样设置session的过期时间,我还可以在tomcat的config目录下的web.xml文件中设置session
的过期时间。
<session-config>
<session-timeout>30</session-timeout>    单位默认是分钟
</session-config>
就是说如果你不另外特别设置session的过期时间的话,就默认使用web.xml中的session的过期时间,如果你单独
设置了过期时间的话,就用你单独设置的那个时间。

*****值得注意的是并不是关闭浏览器就销毁了HttpSession,我们可以采用持久化Cookie的方式关了浏览器下次
还能访问到session,前面也有提到。

利用URL重写实现Session跟踪：
将sessionId以参数形式附加在超链接的URL地址后面的技术称为URL重写。
如果浏览器在不支持Cookie或者关闭了Cookie功能的情况下,WEB服务器还要能够与浏览器实现由状态的会话
就必须对所有可能被客户端访问的请求路径进行URL重写。
HttpServletResponse接口中定义了两个用于完成URL重写的方法：
---encodeURL方法
---encodeRedirectURL方法
<form action="<%=response.encodeURL("hello.jsp") %>" method="post">
这样写一下后你查看源码就会发现在超链接的后面跟着一个jsessionid参数
<form action="hello.jsp;jsessionid=55FFF941BDDFF19E46DE557C8569D161" method="post">


绝对路径和相对路径的问题：
案例：
现在我在根目录下有一个a.jsp页面,然后在根目录下有一个文件夹叫path,这个文件夹下面有b.jsp页面和c.jsp页面
a.jsp页面连向一个servlet,在servlet里面通过转发到b.jsp页面,b.jsp在连到c.jsp页面
代码：
--a.jsp
<body>
	<h3>this is a.jsp page</h3>
	<a href="testServlet">To B Page</a>
</body>
--testServlet
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.getRequestDispatcher("/path/b.jsp").forward(request, response);
}
--b.jsp
<body>
	<h3>this is b.jsp page</h3>
	<a href="c.jsp">To c.jsp page</a>
</body>
下面来说一下这段代码,首先在根目录下我有一个a.jsp通过servlet的方式转发去b.jsp这是没有问题的,但此时
的地址是/testServlet是相对于跟目录,现在我要是在通过超链接的方式去c.jsp由于地址写的是相对路径,所以
它就会去跟目录下找c.jsp这个文件,而c.jsp这个文件是在根目录下的path文件夹下,所以肯定找不到报错。

所以我们写绝对路径就可以结解决上述问题：
①首先我们要明白在JavaWeb中什么叫"绝对路径"？
答：就是相对于当前WEB应用的根路径的路径。      即任何路径都必须带上request.getContextPath()    这个方法获取到的当前的项目名称
②超链接和重定向以及form表单action中的"/"代表当前WEB站点的根目录
<a href="/a.jsp"></a>
response.sendRedirect("a.jsp");					这三种方法地址栏的地址都是localhost:8080/a.jsp
<form action="/a.jsp"></form>


使用session来避免表单的重复提交：
首先要知道何为表单的重复提交：
调用RequestDispatcher.forward()方法,是通过转发的方式去的页面,浏览器所保留的URL是先前表单提交的
URL,此时点击刷新,浏览器将再次提交用户先前输入的数据,引起重复提交。
例如：
--index.jsp
<body>
	<form action="<%=request.getContextPath() %>/tokenServlet" method="post">
		<input type="text" name="name">
		<input type="submit" value="Submit">
	</form>
</body>
--TokenServlet
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		try {
			Thread.sleep(2000L);
		} catch (InterruptedException e) {      ①
			e.printStackTrace();
		}
		String name = request.getParameter("name");
		System.out.println(name);
		request.getRequestDispatcher("/token/success.jsp").forward(request, response);
}
--success.jsp
<body>
	<h3>SUCCESS PAGE</h3>
</body>
代码跑起来之后,我浏览器的实际地址是http://localhost:8080/javaweb1/tokenServlet
这个时候如果我再点击刷新,就会重复提交表单

现在有个情况,加入我在上述代码中加入①处的try catch处代码,那么我项目跑起来,我在index.jsp页面点提交
的时候,就不会立刻被转发去success.jsp页面,会等2秒,那假如这时候我不知道,我有点了一次提交,这样等过了
2秒之后就会发现表单被提交了两次(控制台会打印两次结果)。

下面我们来看下重复提交的情况：
①在表单提交到一个Servlet,而Servlet又通过请求转发的方式响应了一个JSP页面,此时地址栏还保留着Servlet
的那个路径,在响应页面点击刷新。
②在响应页面未到达时重复点击提交按钮。
③点击浏览器上的"后退"按钮,然后再点击提交(这个其实和你在响应页面点击刷新的效果是一样的)

不是重复提交的情况：
点击浏览器的"后退"按钮,然后刷新原表单页面,再点击提交,不算表单的重复提交。(因为你这时候把原表单页面刷新了,就相当于再开一个浏览器页面,然后再填写再提交肯定不算重复提交)

下面看如何避免表单的重复提交：
在表单中做一个标记,提交到Servlet时,检查标记是否存在且是否和预定义的标记一致,若一致,则受理请求并
销毁标记,若不一致或没有标记,则直接响应提示信息："重复提交"。
提供下面几种方案：
①仅提供一个隐藏域：<input type="hidden" name="token" value="Jimmy"/>
这种方案行不通,因为你到Servlet中后没有办法清除这个固定的请求参数。
②把标记放在request中,行不通,因为你点击提交表单又是一个新的请求,不是同一个request,所以根本拿不到值。
③把标记放到session中,可以！
		>>在原表单页面,生成一个随机值
		>>在原表单页面,把随机值放入session属性中
		>>在原表单页面，把随机值放入到隐藏域中
		
		>>在目标的Servlet中,获取session和隐藏域中的随即值
		>>比较两个值是否一致,若一致,受理请求且把session域中的token属性清除
		>>若不一致,则直接响应提示页面："重复提交"
代码：
--index.jsp
<body>
	<form action="<%=request.getContextPath() %>/tokenServlet" method="post">
		<%
			String tokenValue = new Date().getTime()+"";
			session.setAttribute("token", tokenValue);
		%>
		<input type="hidden" name="token" value="<%= tokenValue%>">
		<input type="text" name="name" >
		<input type="submit" value="Submit">
	</form>
</body>
--TokenServlet:
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	try {
		Thread.sleep(2000L);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	HttpSession session = request.getSession();
	Object token = session.getAttribute("token");
	String tokenValue = request.getParameter("token");
	if(token != null && token.equals(tokenValue)){
		session.removeAttribute("token");
	}else{
		response.sendRedirect(request.getContextPath()+"/token/token.jsp");
		return;
	}
	System.out.println(request.getServletPath());
	String name = request.getParameter("name");
	System.out.println(name);
	request.getRequestDispatcher("/token/success.jsp").forward(request, response);
}
--token.jsp
<body>
	<h3>对不起，已经提交过了</h3>
</body>
--success.jsp
<body>
	<h3>SUCCESS PAGE</h3>
</body>



-----------------------------------------------------------------------------------------------
																学韩顺平spring记录的笔记
-----------------------------------------------------------------------------------------------
spring是什么？
答:spring是一个容器框架,用于配置bean并维护bean之间关系的框架。

spring中bean的概念:
这里的bean可以是java中任何一种对象,javabean、service、数据源、DAO (想想我们在bean的配置文件中不知配置过service、数据源、DAO等bean嘛,像这样<bean></bean>)

spring框架它可以管理web层、业务层、DAO层、持久层,它横跨这几个层。可以配置各个层的组件(bean),并且维护各个bean之间的关系
那为什么叫它容器框架？因为你想嘛将来你的web层也好,service层也好到时候就可以把它注入到容器里面去
就在容器里面配,然后这些东西就不需要new了。

spring一个简单的入门案例:
1、引入spring相关的jar包和common-loggin.jar包
2、创建spring的一个核心文件applicationContext.xml,该文件一般放在src目录下。
代码:
我先写一个UserService.java类：
public class UserService {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}
}
按照传统方式我们想要调用这个类里面的方法,我该这么做:
写一个TestService.java类:
public class TestService {
	public static void main(String[] args) {
		UserService userService = new UserService();
		userService.setName("Jimmy");
		userService.sayHello();
	}
}
实例化该类的对象,然后调用方法。
现在我们采用spring来做:
首先编写spring的配置文件applicationContext.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 在容器文件中配置bean(这个bean可以是service/dao/domain/action/数据源) -->
	<bean id="userService" class="com.iflytek.spring.service.UserService">①
		<property name="name">③
			<value>Jimmy</value>④
		</property>⑤
	</bean>②
</beans>
解释一下上面配置的bean：
当我们的spring框架加载的时候,我们的spring就会去看配置文件里面有没有配置bean,如果发现配置了bean
它就会去实例化这个bean,并且把它加载到内存里面去。

①②两行代码的意思就是:
相当于UserService userService = new UserService();        这个id的值就对应着实例化对象名

③④⑤三行代码意思就是:
相当于userService.setName("Jimmy");

好现在配置文件我们写完了,现在来写测试:
TestService.java类:
public class TestService {
	public static void main(String[] args) {		
		//1.得到spring的applicationContext对象(这个applicationContext就可以代表spring容器)
		ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
		UserService us = (UserService) ctx.getBean("userService");     ctx就是spring容器,这句话意思就是你从这个容器里面拿这个bean
		us.sayHello();
	}
}
你会发现我并没有去创建UserService对象,直接就去调用它的方法了。因为我们把创建对象交给了spring去做
spring框架在初始化的时候就会根据配置文件把bean给你创建好,同时注入相关属性。像上面③④⑤处代码就体现了注入的概念,就是把属性给你注入到这个bean里面去了。

现在重点解释一下上面测试类的代码:
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
这行代码一旦被执行,它就会去类路径下找这个applicationContext.xml文件,spring容器就会被创建
同时这个配置文件里面配置的bean就会被实例化到内存中。
所以我们可以得出一个结论就是ApplicationContext这个对象它是一个重量级的对象,因此我们在开发中
应该保持这个对象它是单例的。就相当于hibernate中的sessionfactory一样,是重量级对象应该保证单例。

UserService us = (UserService) ctx.getBean("userService");
解释一下这行代码通过getBean为什么就能获取到这个对象实例:
这牵扯到spring底层的代码,其实当你spring框架被加载的时候,配置文件中的bean会通过反射给你创建好实例
然后底层相当于用HashMap,就是底层代码ctx= new HashMap();  ctx.put("userService",userService);
key是你配置bean的id,value是通过反射创建bean实例的引用。等到把所有的bean都put进去后。我再把这个
ctx引用给你这个ApplicationContext对象。这样你就能通过get方法得到对象实例了。

根据上面的案例我们再总结一下:
spring是一个容器框架,它可以接管web层、业务层、持久层、DAO层的各个组件,并且可以配置各种bean而且它
维护bean与bean之间的关系,当我们要使用某个bean的时候,我们可以getBean(id)就可以了。

IOC是什么？
Inverse Of Control控制反转
所谓控制反转就是把创建对象(bean)和维护对象(bean)的关系的权利从程序中转移到spring的容器(applicationContext.xml)

DI是什么？
dependency injection 依赖注入
下面根据代码来解释这个依赖注入:
UserService.java类：
public class UserService {
	private String name;
	
	private ByeService byeService;
	
	public ByeService getByeService() {
		return byeService;
	}

	public void setByeService(ByeService byeService) {
		this.byeService = byeService;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}
}
这个UserService里面有两个属性一个name一个byeService,这个ByeService它是一个类。
好现在我在spring的配置文件中配置这个bean:
<bean id="userService" class="com.iflytek.spring.service.UserService">
	<property name="name">
		<value>Jimmy</value>
	</property>
	<property name="byeService" ref="byeService"></property>
</bean>
<bean id="byeService" class="com.iflytek.spring.service.ByeService">
	<property name="name" value="kimi"></property>
</bean>
上面的这个bean是不是依赖下面的这个bean的,我通过关联下面的这个bean就把这个byeService属性给它
注入进去了,上面的name属性也体现注入的过程。所以叫依赖注入。

spring开发提倡接口编程,配合DI技术可以实现层与层之间的解耦。
下面就来说一下怎么实现解耦的：
现在我有一个接口Changeletter.java:
public interface Changeletter {
	public String change();
}
下面有两个它的实现类：
Lower2Upper.java：
public class Lower2Upper implements Changeletter {
	private String str;
	
	public String getStr() {
		return str;
	}

	public void setStr(String str) {
		this.str = str;
	}
	
	//小写字母转大写字母
	@Override
	public String change() {
		return str.toUpperCase();
	}
}
Upper2Lower.java：
public class Upper2Lower implements Changeletter {
	private String str;
	
	public String getStr() {
		return str;
	}

	public void setStr(String str) {
		this.str = str;
	}
	
	//把大写字母变成小写字母
	@Override
	public String change() {
		return str.toLowerCase();
	}
}
现在我在配置文件里面去配置bean：
注：
spring的配置文件不一定叫applicationContext.xml叫什么都可以,有些人喜欢叫它beans.xml
因为它认为这个配置文件里面就是配置的一堆bean
beans.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	 <bean id="lower2Upper" class="com.iflytek.spring.interfaces.Lower2Upper">
	 	<property name="str" value="love"></property>
	 </bean>			②
	 
	 <!--
	 <bean id="lower2Upper" class="com.iflytek.spring.interfaces.Upper2Lower">
	 	<property name="str" value="LOVE"></property>
	 </bean>     ①
	 -->
</beans>
上面配置了两个实现类bean,一个小写转大写,一个大写转小写。先假设它们两的id是一样的,我先把第二个屏蔽起来。

下面编写测试类:
TestService.java:
public class TestService {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/interfaces/beans.xml");
		Changeletter lu = (Changeletter) ctx.getBean("lower2Upper");
		String str = lu.change();
		System.out.println(str);
	}
}
这样我跑的结果就是LOVE,现在我要是把①处代码打开②处代码屏蔽,发现它调的就是另一个方法,输出结果love
这样面向接口编程的好处就是我只要调用你的接口就可以了而不用关心你接口是怎么具体实现的。
原来WEB层直接调用service层,所以这两层之间是有耦合关系的。现在我WEB层和service层之间有个接口,
我WEB层直接调用接口,至于你接口service层怎么实现我不关系,这样WEB层和service层之间的耦合关系就解开了。
达到了解耦的目的。

spring的bean工厂和applicationContext:
bean工厂介绍:
工厂设计模式,创建分发各种bean配置好它们之间的协作关系,参与bean的生命周期。
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationConxte.xml"));
bean工厂只把bean的定义信息载进来,用到的时候才实例化。
factory.getBean("mybean");就可以得到一个bean

在上面我们就说了ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/ioc/beans.xml");
当上面这句代码一执行的时候,配置文件里面的所有bean就会被实例化。那我怎么证明它被实例化了呢？
现在有一个student.java类:
public class Student {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public Student() {
		System.out.println("容器初始化时候创建了bean");
	}
}
我写了一个构造方法,要是构造方法里面的内容被打印出来了证明这个类确实被创建了。

spring配置文件beans.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="student" class="com.iflytek.spring.ioc.Student">
		<property name="name" value="Jimmy"></property>
	</bean>
</beans>

测试类TestStudent.java:
public class TestStudent {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/ioc/beans.xml");
		②
	}
}
一运行发现打印出上面Student类的构造方法里面的内容。证明容器加载的时候bean确实被创建了。

下面看下使用beanFactory去获取一个bean:
使用beanFactory去获取bean,当我们去加载spring容器的时候,它不会立即创建配置文件里面的bean实例
也就是BeanFactory factory = new XmlBeanFactory(new ClassPathResource("com/iflytek/spring/ioc/beans.xml"));
上面这行代码执行的时候配置在beans.xml里面的bean不会立即被创建。
只有当你去使用这个bean的时候,bean才会被实时的创建。
案例代码:
Student.java类和beans.xml和上面的都一样,测试类换了一下:
TestStudent.java:
public class TestStudent {
	public static void main(String[] args) {
		BeanFactory factory = new XmlBeanFactory(new ClassPathResource(
				"com/iflytek/spring/ioc/beans.xml"));③
		Student stu = (Student) factory.getBean("student");①
	}
}
首先我不加①处的代码运行,发现Student类的构造方法没有被调用,加上①处的代码后才发现Student类的
构造方法被调用即这个bean才被创建。

那我们到底是用ApplicationContext去获取bean还是用bean工厂去获取bean好呢？
在开发中我们绝大多数是用ApplicationContext去获取bean,除非你的设置内存很小需要节约内存才使用
bean工厂去获取bean。(因为bean工厂在容器实例化的时候不会创建bean,用到bean的时候才创建节约内存)

所以关于ApplicationContext和bean工厂我们得出下面结论:
如果使用ApplicationContext,则配置的bean不管你用不用都会被实例化。(好处就是预先加载,缺点就是一次性加载那么多bean耗内存)
如果使用BeanFactory,当你实例化该对象的时候,配置的bean不会马上被创建,当你使用的时候才会被创建。

注：
上面说的使用ApplicationContext和使用BeanFactory都是指的使用②③处的代码去加载spring配置文件开启spring容器。

bean的scope属性：
在这里主要说两个值singleton和prototype
案例代码:
beans.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="student" scope="singleton" class="com.iflytek.spring.ioc.Student">
		<property name="name" value="Jimmy"></property>
	</bean>
</beans>
你配置成singleton它只会给你创建一个bean对象,单例bean
如果配置成prototype就会你每次去get的时候都会创建一个新的bean 

测试代码:
TestStudent.java
public class TestStudent {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext(
				"com/iflytek/spring/ioc/beans.xml");
		 Student stu = (Student) ctx.getBean("student");
		 Student stu1 = (Student) ctx.getBean("student");
		 System.out.println(stu+","+stu1);
	}
}
如果你使用singleton发现打出来两个地址值是一样的,使用prototype打出来的地址值是不一样的因为你每次get都会去新创建一个bean

bean的生命周期:
bean被载入到容器后它的生命周期就开始了。
1、实例化(当我们程序加载applicationContext.xml文件)我们的bean(前提是这个bean的scope="singleton"),
就会被实例化到内存。
案例代码:
PersonService.jave类:
public class PersonService {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}
}
spring配置文件beans.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="personService" class="com.iflytek.spring.beanlife.PersonService">
		<property name="name" value="Jimmy"></property>
	</bean>
</beans>
测试类TestPerson.java:
public class TestPerson {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/beanlife/beans.xml");
		PersonService ps = (PersonService) ctx.getBean("personService");
		ps.sayHello();
	}
}
我在PersonService的无参构造器里面打印的一句话,当我运行测试类spring容器加载的时候,发现确实调用了
无参的构造器。

2、调用set方法设置属性
案例代码:
PersonService.jave类:
public class PersonService {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("调用了set方法");
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}
}
beans.xml和测试类都和上面一样。当我运行测试类的时候,会发现这个setXXX方法会被调用。
而且控制台是先打印出"无参的构造方法"后打印出"调用了set方法"。这也证明了是先实例化然后再设置属性。

3、如果你实现了BeanNameAware(bean名字关注)接口,则可以通过接口里面的方法的传入参数获取id号
案例代码:
public class PersonService implements BeanNameAware {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("调用了set方法");
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}

	@Override
	public void setBeanName(String arg0) {
		System.out.println("实例化bean的id是："+arg0);
		
	}
}
我们都知道在spring的配置文件中配置的bean的id就是你bean被实例化后的名字,现在我实现BeanNameAware
这个接口,重写setBeanName这个方法,方法里面传入的参数就是我配置文件中配置的bean的id。
运行后发现控制台打印出"无参的构造方法"和"调用了set方法"和"实例化bean的id是：personService"
因为我在配置文件里面配置的bean的id就是personService。

4、如果你实现了BeanFactoryAware(bean工厂关注)接口,则可以通过接口里面的方法的传入参数获取beanFacory
案例代码:
public class PersonService implements BeanNameAware,BeanFactoryAware {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("调用了set方法");
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}

	@Override
	public void setBeanName(String arg0) {
		System.out.println("实例化bean的id是："+arg0);
		
	}

	@Override
	public void setBeanFactory(BeanFactory arg0) throws BeansException {
		System.out.println("得到beanFactory"+arg0.getBean("personService"));
		
	}
}
运行测试类后发现控制台打印出:"无参的构造方法"和"调用了set方法"和"实例化bean的id是：personService"
和"得到beanFactorycom.iflytek.spring.beanlife.PersonService@be5687"这样我们发现确实是得到了
BeanFactory因为传入的arg0参数可以.getBean()方法。在这个方法里面我们就可以得到配置文件里面配置的
任何一个bean了

5、如果你实现了ApplicationContextAware(ApplicationContext关注)接口,则可以通过接口里面的方法的传入参数获取ApplicationContext
public class PersonService implements BeanNameAware,BeanFactoryAware,ApplicationContextAware {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("调用了set方法");
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}

	@Override
	public void setBeanName(String arg0) {
		System.out.println("实例化bean的id是："+arg0);
		
	}

	@Override
	public void setBeanFactory(BeanFactory arg0) throws BeansException {
		System.out.println("得到beanFactory"+arg0.getBean("personService"));
	}

	@Override
	public void setApplicationContext(ApplicationContext arg0)
			throws BeansException {
		System.out.println("得到applicationContext"+arg0);
	}
}
运行测试类后发现控制台打印出:"无参的构造方法"和"调用了set方法"和"实例化bean的id是：personService"
和"得到beanFactorycom.iflytek.spring.beanlife.PersonService@be5687"和"得到applicationContext加上这个对象的一大串地址这里就不写上了"
所以你实现这个接口后就可以通过参数得到applicationContext对象。

6、如果一个bean和后置处理器关联,则会自动去调用处理器里面的方法
也就是说如果我写一个类实现了BeanPostProcessor接口,然后又把这个类配置到spring的配置文件中,那么
这个BeanPostProcessor接口里面的方法就会被自动调用。
案例代码:
自己写了一个类MyBeanPostProcessor.java:
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessAfterInitialization(Object arg0, String arg1)
			throws BeansException {
		System.out.println("After方法被调用");
		return arg0;
	}

	@Override
	public Object postProcessBeforeInitialization(Object arg0, String arg1)
			throws BeansException {
		System.out.println("Before方法被调用");
		return arg0;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="personService" class="com.iflytek.spring.beanlife.PersonService">
		<property name="name" value="Jimmy"></property>
	</bean>
	<bean id="myBeanPostProcessor" class="com.iflytek.spring.beanlife.MyBeanPostProcessor">
	</bean>
</beans>
我写了一个类,而且这个类实现了BeanPostProcessor接口,然后我把这个类配置到spring的配置文件中
这样这个myBeanPostProcessor bean就和一个BeanPostProcessor处理器关联了。
那么我spring容器加载的时候就会去自动调用postProcessBeforeInitialization和postProcessAfterInitialization方法。
我运行一下测试类发现控制台打出的是:
"无参的构造方法"和"调用了set方法"和"实例化bean的id是：personService"
和"得到beanFactorycom.iflytek.spring.beanlife.PersonService@be5687"
和"得到applicationContext加上这个对象的一大串地址这里就不写上了"和"Before方法被调用" "After方法被调用"

经过上面几步bean就会创建好就可以使用了。

再看一段代码:
public class PersonService{
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("调用了set方法");
		this.name = name;
	}
	public PersonService() {
		// TODO Auto-generated constructor stub
		System.out.println("无参的构造方法");
	}
	
	public void sayHello(){
		System.out.println("hello"+name);
	}
	
	public void destorys(){
		//当容器关闭后在这个方法里面释放资源
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="personService" destroy-method="destorys" class="com.iflytek.spring.beanlife.PersonService">
		<property name="name" value="Jimmy"></property>
	</bean>
</beans>
我在上面PersonService里面写了一个destory方法,然后我在spring配置文件里面配一下destroy-method="destorys"
就相当于在这个bean里面定制一个销毁的方法,当spring容器关闭的时候会自动调用我定制的这个方法。
所以我们就可以在这个方法里面释放一些资源等。

装配bean:
在spring容器内拼凑bean叫做装配。装配bean的时候,需要告诉容器有哪些bean以及容器如何使用依赖注入
将它们配合在一起。

装配List:
Department.java类:
public class Department {
	private String name;
	private List<Employee>empList;

	public List<Employee> getEmpList() {
		return empList;
	}

	public void setEmpList(List<Employee> empList) {
		this.empList = empList;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="department" class="com.iflytek.spring.collection.Department">
		<property name="empList">
			<list>
				<ref bean="emplpyee"/>
				<ref bean="emplpyee2"/>
			</list>
		</property>
		
	</bean>
	<bean id="emplpyee" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="Jimmy"></property>
	</bean>
	<bean id="emplpyee2" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="kimi"></property>
	</bean>
</beans>
测试类TestDepartment.java:
public class TestDepartment {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext(
				"com/iflytek/spring/collection/beans.xml");
		Department department = (Department) ctx.getBean("department");
		List<Employee> empList = department.getEmpList();
		for (Employee e : empList) {
			System.out.println(e.getName());
		}
	}
}

装配Set:
Department.java类:
public class Department {
	private String name;
	private Set<Employee>empSet;
	
	public Set<Employee> getEmpSet() {
		return empSet;
	}

	public void setEmpSet(Set<Employee> empSet) {
		this.empSet = empSet;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="department" class="com.iflytek.spring.collection.Department">
		<property name="empSet">
			<set>
				<ref bean="emplpyee2"/>
				<ref bean="emplpyee"/>
			</set>
		</property>
	</bean>
	<bean id="emplpyee" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="Jimmy"></property>
		<property name="id" value="1"></property>
	</bean>
	<bean id="emplpyee2" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="kimi"></property>
		<property name="id" value="2"></property>
	</bean>
</beans>
测试类TestDepartment.java:
public class TestDepartment {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext(
				"com/iflytek/spring/collection/beans.xml");
		Department department = (Department) ctx.getBean("department");
		Set<Employee> empSet = department.getEmpSet();
		for (Employee e : empSet) {
			System.out.println(e.getName());
		}
	}
}

装配map:
Department.java类:
public class Department {
	private String name;
	private Map<Integer, Employee>empMap;
	
	public Map<Integer, Employee> getEmpMap() {
		return empMap;
	}

	public void setEmpMap(Map<Integer, Employee> empMap) {
		this.empMap = empMap;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="department" class="com.iflytek.spring.collection.Department">
		<property name="empMap">
			<map>
				<entry key="1" value-ref="emplpyee"></entry>
				<entry key="2" value-ref="emplpyee2"></entry>
			</map>
		</property>
	</bean>
	<bean id="emplpyee" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="Jimmy"></property>
		<property name="id" value="1"></property>
	</bean>
	<bean id="emplpyee2" class="com.iflytek.spring.collection.Employee">
		<property name="name" value="kimi"></property>
		<property name="id" value="2"></property>
	</bean>
</beans>
测试类TestDepartment.java:
public class TestDepartment {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext(
				"com/iflytek/spring/collection/beans.xml");
		Department department = (Department) ctx.getBean("department");
		Map<Integer, Employee> empMap = department.getEmpMap();
		for(Entry<Integer, Employee>entry:empMap.entrySet()){
			Integer key = entry.getKey();
			String name = entry.getValue().getName();
			System.out.println(key+":"+name);
		}
	}
}

继承bean的配置:
父类Student.java:
public class Student {
	protected String name;
	protected int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}
子类GraduateStu.java:
public class GraduateStu extends Student{
	private String degree;

	public String getDegree() {
		return degree;
	}

	public void setDegree(String degree) {
		this.degree = degree;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="student" class="com.iflytek.spring.inhert.Student">
		<property name="name" value="Jimmy"></property>
		<property name="age" value="44"></property>
	</bean>
	<bean id="graduateStu" parent="student" class="com.iflytek.spring.inhert.GraduateStu">
		<!-- 这里配置了parent子类就可以继承父类是 -->
		<property name="degree" value="学士"></property>
		<!-- 如果在这里我自己配置name和age则会替换父类的数据 -->
		<property name="age" value="22"></property>①
		<property name="name" value="shp"></property>②
	</bean>
</beans>
测试类TestStudent.java:
public class TestStudent {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/inhert/beans.xml");
		GraduateStu gs = (GraduateStu) ctx.getBean("graduateStu");
		System.out.println(gs.getAge()+":"+gs.getName()+":"+gs.getDegree());
	}
}
如果我没有写①和②处的代码,打印出来的结果应该是44:Jimmy:学士。加上后结果就是22:shp:学士

给属性为Properties进行注入:
Student.java类:
public class Student {
	protected String name;
	protected int age; 
	
	private Properties properties;
	
	public Properties getProperties() {
		return properties;
	}

	public void setProperties(Properties properties) {
		this.properties = properties;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="student" class="com.iflytek.spring.inhert.Student">
		<property name="name" value="Jimmy"></property>
		<property name="age" value="44"></property>
		<property name="properties">    这里配的是你Student类里面的属性
			<props>
				<prop key="aa">123</prop>   这里写properties里面的key和value
				<prop key="bb">456</prop>
			</props>
		</property>
	</bean>
</beans>

TestStudent.java测试类:
public class TestStudent {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/inhert/beans.xml");
		Student stu = (Student) ctx.getBean("student");
		Properties properties = stu.getProperties();
		for(Entry<Object, Object>entry :properties.entrySet()){
			System.out.println(entry.getKey()+":"+entry.getValue());
		}
	}
}

构造方法注入:
Employee.java:
public class Employee {
	private String name;
	private Integer id;
	
	public Employee() {
	}
	
	public Employee(String name, Integer id) {
		this.name = name;
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}
}
beans.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id="employee" class="com.iflytek.spring.contructor.Employee">
		<constructor-arg index="0" type="java.lang.String" value="Jimmy"></constructor-arg>   index表示第几个参数,type表示参数的类型,value表示参数值
		<constructor-arg index="1" type="java.lang.Integer" value="1"></constructor-arg>
	</bean>
</beans>

TestEmployee.java测试类:
public class TestEmployee {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/contructor/beans.xml");
		Employee emp = (Employee) ctx.getBean("employee");
		System.out.println(emp.getName()+":"+emp.getId());
	}
}

自动装配:
Dog.java:
public class Dog {
	private String name;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "Dog [name=" + name + ", age=" + age + "]";
	}
}
Master.java:
public class Master {
	private String name;
	private Dog dog;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Dog getDog() {
		return dog;
	}

	public void setDog(Dog dog) {
		this.dog = dog;
	}
}
beans.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="master" class="com.iflytek.spring.autowire.Master" autowire="byName">①
		<property name="name" value="Jimmy"></property>
	</bean>
	
	<bean id="dog" class="com.iflytek.spring.autowire.Dog">②
		<property name="age" value="4"></property>
		<property name="name" value="kimi"></property>
	</bean>
</beans>
TestMaster.java测试类:
public class TestMaster {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/autowire/beans.xml");
		Master master = (Master) ctx.getBean("master");
		System.out.println(master.getName()+","+master.getDog());
	}
}
如果我不加①处代码autowire="byName",我在测试类里面master.getDog()得到的结果是一个空。
加了autowire="byName"后,spring配置文件在被加载的时候,在加载id="master"这个bean的时候,因为Master
这个类下面有一个属性名叫dog,它就会在配置文件里面去找看有没有一个对象的名字叫dog的,如果有这两个
bean就被关联起来了。假如我把②处bean的id改为dog1,它还是会在配置文件里面去找看有没有一个对象的
名字叫dog的,这时候没有那么master.getDog()得到的就是空。

通过autowire="byType"去装配:
前面的Dog.java Master.java TestMaster.java测试类都一样。
beans.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="master" class="com.iflytek.spring.autowire.Master" autowire="byType">③
		<property name="name" value="Jimmy"></property>
	</bean>
	
	<bean id="dog" class="com.iflytek.spring.autowire.Dog">
		<property name="age" value="4"></property>
		<property name="name" value="kimi"></property>
	</bean>
	
	<bean id="dog2" class="com.iflytek.spring.autowire.Dog">④
		<property name="age" value="5"></property>
		<property name="name" value="tony"></property>
	</bean>
</beans>
通过类型自动注入,因为我这个Master类里面有个Dog类,你使用autowire="byType"它就会在配置文件里面找
看有没有一个类型是Dog类的,很显然是通过class去找。发现有一个这两个bean就关联起来了。
但是如果你配置文件里面有两个bean的类型都是Dog,就会报错。也就是我加上④处的代码,它匹配的时候就会
发现有两个bean都是Dog类型不知道匹配哪一个报错。

<context:annotation-config></context:annotation-config>:
在spring的配置文件中加上上面这段代码可以激活在类中探测到的各种注解。
比如说你想使用@Autowired注解，那么就必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor Bean。
传统声明方式如下：<bean class="org.springframework.beans.factory.annotation. AutowiredAnnotationBeanPostProcessor "/>
你想使用其他注解像@ Resource、@Required同样都要配置bean。
一般来说，这些注解我们还是比较常用，尤其是Antowired的注解，在自动注入的时候更是经常使用，
所以如果总是需要按照传统的方式一条一条配置显得有些繁琐和没有必要，于是spring给我们提供<context:annotation-config/>的简化配置方式，自动帮你完成声明。
不过，我们使用注解一般都会配置扫描包路径选项：
<context:component-scan base-package=”XX.XX”/> 
该配置项其实也包含了自动注入上述processor的功能，因此当使用 <context:component-scan/> 后，就可以将 <context:annotation-config/> 移除了。

<context:property-placeholder/>:
可以读取配置文件信息。
案例代码:
DBUtils.java:
public class DBUtils {
	private String userName;
	private String password;
	private String url;
	private String driverName;
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getDriverName() {
		return driverName;
	}
	public void setDriverName(String driverName) {
		this.driverName = driverName;
	}
}

db.properties:
userName=root
password=123
url=jdbc:mysql://localhost:3306/test
driverName=com.mysql.jdbc.Driver

beans.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">
	
	<context:property-placeholder location="classpath:com/iflytek/spring/dispatch/db.properties,classpath:com/iflytek/spring/dispatch/db.properties"/>
	<bean id="dbUtils" class="com.iflytek.spring.dispatch.DBUtils">
		<property name="driverName" value="${driverName}"></property>
		<property name="url" value="${url}"></property>          配置了<context:property-placeholder/>我就可以直接用el表达式那配置文件中的值
		<property name="password" value="${password}"></property>
		<property name="userName" value="${userName}"></property>
	</bean>
</beans>
注意：spring容器中最多只能定义一个context:property-placeholder。你如果要引用多个文件,在location
中中用逗号分隔。
TestDB.java测试类：
public class TestDB {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/dispatch/beans.xml");
		DBUtils db = (DBUtils) ctx.getBean("dbUtils");
		System.out.println(db.getDriverName());
	}
}
这样我运行测试类的时候,会打出从配置文件拿到的driverName的值。

AOP:
先说一下aop是什么？
答：面向切面编程,是对所有对象或者是一类对象编程,核心是在不增加代码的基础上,还增加新功能。

案例代码:
TestServiceInter.java接口:
public interface TestServiceInter {
	public void sayHello();
}

TestServiceInter2.java接口:
public interface TestServiceInter2 {
	public void sayBye();
}

TestService.java实现类:
public class TestService implements TestServiceInter,TestServiceInter2 {
	
	private String name;
	@Override
	public void sayHello() {
		System.out.println("hi"+name);
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Override
	public void sayBye() {
//		int a = 2/0;
		System.out.println("bye"+name);
	}
}

前置通知MyMethodBeforeAdvice.java:
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
	
	/**
	 * method:被调用方法的名字
	 * args:给method传递的参数
	 * target:目标对象
	 */
	@Override
	public void before(Method method, Object[] args, Object target)
			throws Throwable {
		System.out.println("记录日志..."+method.getName());
	}
}

后置通知MyAfterReturningAdvice.java:
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	
	/**
	 * returnValue:方法的返回值
	 * method:调用的是哪个方法
	 * args:调用方法传的参数
	 * 
	 */
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args,
			Object target) throws Throwable {
		System.out.println("后置通知开始工作了。。。");
	}
}

环绕通知MyMethodInterceptor.java:
public class MyMethodInterceptor implements MethodInterceptor {

	@Override
	public Object invoke(MethodInvocation arg0) throws Throwable {
		
		System.out.println("方法调用前。。");
		Object object = arg0.proceed();
		System.out.println("方法调用后。。");
		return object;     //注意这里一定要有返回值否则方法会不执行。
	}
}

异常通知MyThrowAdvice.java:
public class MyThrowAdvice implements ThrowsAdvice {
	//ThrowsAdvice是一个标识性接口,里面没有任何方法
	//所以我可以自己写一个方法,但是这个方法最好和像前置、后置、环绕通知格式一样
	public void afterThrowing(Method method, Object[]object, Object target, Exception e){
		System.out.println("抛异常了"+e);
	}
}

beans.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- 配置被代理的对象 -->
	<bean id="testService" class="com.iflytek.spring.aop.TestService">
		<property name="name" value="Jimmy"></property>
	</bean>
	
	<!-- 配置前置通知 -->
	<bean id="myMethodBeforeAdvice" class="com.iflytek.spring.aop.MyMethodBeforeAdvice"></bean>	
	
	<!-- 配置后置通知 -->
	<bean id="myAfterReturningAdvice" class="com.iflytek.spring.aop.MyAfterReturningAdvice"></bean>
	
	<!-- 配置环绕通知 -->
	<bean id="myMethodInterceptor" class="com.iflytek.spring.aop.MyMethodInterceptor"></bean>
	
	<!-- 配置异常通知 -->
	<bean id="myThrowAdvice" class="com.iflytek.spring.aop.MyThrowAdvice"></bean>
	
	<!-- 定义前置通知的切入点 -->
	<bean id="myMethodBeforeAdviceFilter" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
		<property name="advice" ref="myMethodBeforeAdvice"></property>
		<property name="mappedNames">
			<list>
				<value>sayHello</value>		<!--这样我前置通知只对指定的方法有效  -->
			</list>
		</property>
	</bean>
	
	<!-- 配置代理对象 -->
	<bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean">
		<!-- 代理的接口集 -->
		<property name="proxyInterfaces">
			<list>
				<value>com.iflytek.spring.aop.TestServiceInter</value>
				<value>com.iflytek.spring.aop.TestServiceInter2</value>
			</list>
		</property>
		<!-- 把通知织入到代理对象 -->
		<property name="interceptorNames">
			<list>
				<value>myMethodBeforeAdviceFilter</value>
				<value>myAfterReturningAdvice</value>
				<value>myMethodInterceptor</value>
				<value>myThrowAdvice</value>
			</list>
		</property>
		<!-- 配置要代理的目标对象 -->
		<property name="target" ref="testService"></property>
	</bean>
</beans>

TestAOP.java测试类:
public class TestAOP {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("com/iflytek/spring/aop/beans.xml");
		TestServiceInter ts = (TestServiceInter) ctx.getBean("proxyFactoryBean");         这里获取的是代理类对象
		ts.sayHello();
		((TestServiceInter2)ts).sayBye();
	}
}

-----------------------------------------------------------------------------------------------
																学尚硅谷spring记录的笔记
-----------------------------------------------------------------------------------------------
ApplicationContext的主要实现类:
--ClassPathXmlApplicationContext:从类路径下加载配置文件。
--FileSystemXmlApplicationContext:从文件系统中加载配置文件。

ConfigurableApplicationContext扩展与ApplicationContext是ApplicationContext的子接口。新增加
两个主要方法:refresh()和close(),让ApplicationContext具有启动、刷新和关闭上下文的能力。

从IOC容器中获取Bean实例:
两种方法:
1、
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
HelloWorld hw = (HelloWorld)ctx.getBean("helloWorld");
2、
HelloWorld hw = ctx.getBean(HelloWorld.class);
这种方式获取不需要强转,因为你已经告诉容器要获取的bean的类型了,但是用这种方式获取bean的时候,
如果你配置文件里面配置了多个类型一样的bean再用这种方式去获取它就不知道获取哪一个了。

spring依赖注入的方式:
--属性注入
--构造器注入
--工厂方法注入(很少使用,不推荐)

字面值:
可用字符串表示的值,可以通过<value>元素标签或value属性进行注入。
基本数据类型及其包装类、String类型都可以采取字面值注入的方式。
*****若字面值中包含特殊字符,可以使用<![CDATA[]]>把字面值包裹起来。

spring配置文件bean之间的关系:继承和依赖

spring允许继承bean的配置,子bean从父bean中继承配置,包括bean的属性配置。子bean可以覆盖从父bean
继承过来的配置。父bean可以作为配置模板,也可以作为bean的实例。若只想把父bean作为模板,可以设置
<bean>的abstract属性为true,这样spring容器就不会实例化这个bean。

spring允许用户通过depends-on属性设定Bean的前置依赖的Bean,前置依赖的Bean会在本Bean实例化之前
创建好。如果前置依赖多个Bean,则可以通过逗号,空格的方式配置Bean的名称。

bean的作用域:
singleton:容器初始化的时候创建bean的实例,在整个容器的生命周期内只创建一个bean,单例的
prototype:原型的,容器初始化的时候不创建bean的实例,而在每次请求的时候都创建一个新的bean实例。

spEL:
spring的表达式语言,是一个支持运行时查询和操作对象图的强大的表达式语言。
语法:
#{}     所有在大括号中的字符都被认为是spEL

通过spEL可以实现
--通过bean的id对bean进行引用
--调用方法以及引用对象中的属性
--计算表达式的值
--正则表达式的匹配

spEL调用静态方法或静态属性：
通过T()调用一个类的静态方法,它将返回一个Class Object,然后再调用相应的方法或属性
如:<property name="initValue" value="#{T(java.lang.Math).PI}"></property>

关于spEL案例代码:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd">
	
	<bean id="address" class="com.iflytek.spring.spel.Address">
		<property name="city" value="#{'合肥'}"></property><!-- 对于字面值也可以使用spel,不过使用意义不大 -->
		<property name="street" value="义城街道"></property>
	</bean>
	<bean id="car" class="com.iflytek.spring.spel.Car">
		<property name="brand" value="BMW"></property>
		<property name="price" value="50000"></property>
		<property name="tyrePerimeter" value="#{T(java.lang.Math).PI * 80}"></property><!-- 使用spel引用类的静态属性 -->
	</bean>
	
	<bean id="person" class="com.iflytek.spring.spel.Person">
		<property name="name" value="Jimmy"></property>
		<!-- 可以通过spel来引用其他的bean,相当于ref="car" -->
		<property name="car" value="#{car}"></property>
		<!-- 使用spel来引用其它bean的属性 -->
		<property name="city" value="#{address.city}"></property>
		<!-- 在spel中使用运算符 -->
		<property name="info" value="#{car.price > 30000 ? '金领':'白领'}"></property>
	</bean>
</beans>
更多参看博客:http://www.cnblogs.com/goodcheap/p/6490896.html

bean的生命周期:
spring的ioc容器对bean的生命周期进行管理的过程:
1、创建bean的实例
2、为bean的属性设置值和对其他bean的引用
3、调用bean的初始化方法
4、bean可以使用了
5、当容器关闭时,调用bean的销毁方法
注:在bean的声明里设置init-method和destroy-method属性,为bean指定初始化和销毁方法。

基于注解的方式配置bean：
我们说配置bean有两种形式：
1、基于XML文件的方式
2、基于注解的方式(基于注解来配置bean,基于注解来装配bean的属性)

组件扫描:
Spring能从classpath下自动扫描、侦测和实例化具有特定注解的组件。
特定组件包括:
--@Component:基本注解,标识了一个受Spring管理的组件。
--@Repository:标识持久层组件。
--@Service:标识业务层组件。
--@Controller:控制层组件
对于扫描到的组件,Spring有默认的命名策略:使用类名第一个字母小写。也可以在注解中通过value属性值
标识组件名称。 
注:实际上这四个注解目前在Spring里面是可以混用的,因为IOC容器没办法识别到你这个类是一个持久层的还
是一个表现层的。

当在组件类上使用了特定的注解以后,还需要在Spring的配置文件中声明<context:component-scan>
--base-package属性指定了一个需要扫描的基类包,Spring容器将会扫描这个基类包里及其子包中的所有类。
--当需要扫描多个包时,可以使用逗号分离。
--如果仅希望扫描特定的类而非基类包下的所有类,可使用resource-pattern属性过滤特定的类。
--<context:include-filter>子节点表示要包含的目标类
--<context:exclude-filter>子节点表示要排除在外的目标类
案例代码:
UserRespository.java接口:
public interface UserRespository {
	public void save();
}

UserRespositoryImpl.java实现类:
@Repository
public class UserRespositoryImpl implements UserRespository {
	@Override
	public void save() {
		System.out.println("UserRespositoryImpl的save()方法");
	}
}
beans.xml文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">
	<context:component-scan base-package="com.iflytek.spring.annotation">
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/>①
	</context:component-scan>
</beans>
我在实现类上面加了一个注解,然后在spring的配置文件中配置了一个扫描器,当spring的IOC容器被加载的时候
就会自动去扫描classpath下的标有注解的组件类,然后这些标有注解的组件类就纳入了IOC容器的管理。
就会在IOC容器启动的时候去创建对应的实例。
说下①处代码的作用,<context:exclude-filter>表示要排除的目标类,属性使用type="annotation" 表示
只要注解是后面expression的属性值都把它排除在外不加入IOC容器管理。

在上面我们也说了,我们在对应的bean上面添加了相应的注解,然后在spring的配置文件里面写了一个
<context:component-scan>,然后我们就可以把标识注解的那些bean交给IOC容器进行管理。

注:
<context:component-scan>元素还会自动注册AutowiredAnnotationBeanPostProcessor实例,该实例可以自动
装配具有@Autowired和@Resource、@Inject注解的属性。什么意思呢？
就比如说我在private Userservice userservice这个属性上加上@Autowired属性,它就会自动的把这个bean
给装配上。

注意:
@Autowired
private Userservice userservice
所有使用@Autowired注解的属性都要被设置,也就是说你这个bean在spring的IOC容器中要有,不然就报错。
还有一点:
就是你这个@Autowired标识的是一个接口,要是这个接口有好几个实现类怎么办呢？
就拿上面的Userservice举例,这个Userservice是一个接口,它有几个实现类。
这时候它就会去找实现类,看看有没有一个实现类的名字叫userservice的,要是有就用这个实现类,没有就报错。
案例代码:
UserService.java:
@Service
public class UserService {
	@Autowired
	private UserRespository userRespository;
	public void add(){
		System.out.println("UserService add方法");
		userRespository.save();
	}
}
UserRespository.java接口:
public interface UserRespository {
	public void save();

}
UserRespositoryImpl.java实现类:
@Repository("userRespository")			①
public class UserRespositoryImpl implements UserRespository {
	@Override
	public void save() {
		System.out.println("UserRespositoryImpl的save()方法");
	}
}
UserJDBC.java实现类:
@Repository
public class UserJDBC implements UserRespository {
	@Override
	public void save() {
	}
}
这样UserRespository这个接口就有两个实现类,你在Userservice中用@Autowired去标识UserRespository
这个接口的时候它就会去找看实现类中有没有一个实现类叫userRespository,有就调用这个实现类的方法
要是没有就报错。
另一种方式就是:
假设我没有写①处的代码,那么它找不到这个名字叫userRespository的肯定会报错。
然后我们可以这么写：
UserService.java:
@Service
public class UserService {
	@Autowired
	@Qualifier("userRespositoryImpl")         加上这行代码指明它要用哪个实现类也是可以的,即指明注入bean的名称
	private UserRespository userRespository;
	public void add(){
		System.out.println("UserService add方法");
		userRespository.save();
	}
}

aop:
AspectJ:
Java社区里最完整最流行的AOP框架。
在Spring2.0以上版本中,可以使用基于AspectJ注解或基于XML配置AOP。

在Spring中启用AspectJ注解支持:
--要在Spring应用中使用AspectJ注解,必须在classpath下包含AspectJ类库：
aopalliance.jar、aspectj.weaver.jar、spring-aspects.jar
--要在SpringIOC容器中启用AspectJ注解支持,只要在Bean配置文件中定义一个空的XML元素<aop:aspectj-autoproxy/>
--当SpringIOC容器侦测到bean配置文件中的<aop:aspectj-autoproxy/>元素时,会自动为与AspectJ切面匹配的Bean创建代理。

这个<aop:aspectj-autoproxy/>详细介绍:
当我调用一个目标方法的时候,如果这个目标方法跟我切面里面写的注解(如@before)所声明的方法(excution里面的东西)匹配时,
aop框架会自动为目标方法所在的类生成代理对象,然后在调用目标方法之前把通知的内容先打出来。

aop使用aspectJ案例代码:
ArithmeticCalculator.java接口:
public interface ArithmeticCalculator {
	int add(int i, int j);
	int sub(int i, int j);
	
	int mul(int i, int j);
	int div(int i, int j);
}
ArithmeticCalculatorImpl.java实现类:
@Component
public class ArithmeticCalculatorImpl implements ArithmeticCalculator {

	@Override
	public int add(int i, int j) {
		int result = i + j;
		return result;
	}
	@Override
	public int sub(int i, int j) {
		int result = i - j;
		return result;
	}
	@Override
	public int mul(int i, int j) {
		int result = i * j;
		return result;
	}
	@Override
	public int div(int i, int j) {
		int result = i / j;
		return result;
	}
}
定义一个LoggingAspect.java切面:
/*
 * 把一个类声明为一个切面:1.需要把该类放入到IOC容器中 2.再声明为一个切面
 */
@Aspect
@Component
public class LoggingAspect {
	//注意光把这个类声明为一个切面还不行,我要说明下面我的这个方法在哪些类的哪些方法开始之前执行
	//before注解声明该方法是一个前置通知:在目标方法开始之前执行。
	@Before("execution(public int com.iflytek.spring.aop.ArithmeticCalculator.add(int, int))") 在这里要想对接口下所有方法起作用可以把add换成*
	public void beforeMethod(){
		System.out.println("The Method begins");
	}
}
说明：声明一个切面首先要把这个类加入到IOC容器里面去,然后再用@Aspect来说明这个类是一个切面。
applicationContext.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
		
	<context:component-scan base-package="com.iflytek.spring"></context:component-scan>
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>        //配置文件里面如果没配这个,aop的通知就不会生效,因为是靠这个配置去生成代理对象
</beans>

案例代码些许改动:
LoggingAspect.java切面:
@Aspect
@Component
public class LoggingAspect {
	@Before("execution(* com.iflytek.spring.aop.ArithmeticCalculator.add(int, int))")  这里可以把public int换成*表示任意修饰符任意返回值
	public void beforeMethod(JoinPoint joinPoint){
		String methodName = joinPoint.getSignature().getName();       方法名
		List<Object> args = Arrays.asList(joinPoint.getArgs());				方法的参数,返回的是一个数组
		System.out.println("The Method begins"+methodName+args);
	}
}
可以在通知方法中声明一个类型为JoinPoint的参数,然后就能访问连接细节,如方法名称和参数值。

后置通知:
在目标方法执行后(无论是否发生异常),执行通知。
案例代码:  (只是切面做了改动,其它的都一样)
LoggingAspect.java切面:
@Aspect
@Component
public class LoggingAspect {	
	@After("execution(* com.iflytek.spring.aop.*.*(int,int))")        这几个"*"表示任意修饰符任意返回值、com.iflytek.spring.aop这个包下面的所有类、所有方法
	public void afterMethod(JoinPoint joinPoint){
		String methodName = joinPoint.getSignature().getName();
		List<Object> args = Arrays.asList(joinPoint.getArgs());
		System.out.println("The Method ends"+methodName+args);
	}
}

返回通知:
在目标方法正常结束之后执行的代码。返回通知是可以访问到方法的返回值的。
注意:后置通知因为方法可能会出异常,所以是访问不到返回值的,因为它出异常也执行。
案例代码；
@Aspect
@Component
public class LoggingAspect {
	@AfterReturning(value = "execution(* com.iflytek.spring.aop.ArithmeticCalculator.*(..))"
					,returning="result")
	public void afterReturning(JoinPoint joinPoint,Object result){
		String methodName = joinPoint.getSignature().getName();
		List<Object> list = Arrays.asList(joinPoint.getArgs());
		System.out.println("***the method name:"+methodName+"args:"+list+"**返回值："+result);
	}
}
这个returning="result"就是返回值,这个"result"你可以随便起名字,下面方法里面Object result,这个
result一定要跟这个returning="result"一样,因为就是通过这个result把返回值传递过来的。

异常通知:
在目标方法出现异常时会执行的代码,可以访问到异常对象,且可以指定在出现特定异常时,再执行通知。
案例代码:
@Aspect
@Component
public class LoggingAspect {
	@AfterThrowing(value = "execution(* com.iflytek.spring.aop.ArithmeticCalculator.*(..))"
					,throwing="e")
	public void afterThrowing(JoinPoint joinPoint,NullPointerException e){
		String methodName = joinPoint.getSignature().getName();
		List<Object> list = Arrays.asList(joinPoint.getArgs());
		System.out.println("---the method name:"+methodName+"args:"+list+"--异常："+e);
	}
}
返回的异常对象就是写的throwing="e",在通知方法里我可以指定一个异常类型比如NullPointerException,
只有发生空指针异常才会执行这个通知代码。

切面的优先级:
可以使用@Order注解指定切面的优先级,值越小优先级越高。
案例代码:
ValidationAspect.java切面:
@Order(1)
@Aspect
@Component
public class ValidationAspect {
	@Before("execution(* com.iflytek.spring.aop.*.*(..))")
	public void validateArgs(JoinPoint joinPoint){
		System.out.println("validate:"+Arrays.asList(joinPoint.getArgs()));
	}
}

LoggingAspect.java切面:
@Order(2)
@Aspect
@Component
public class LoggingAspect {
	@Before("execution(* com.iflytek.spring.aop.ArithmeticCalculator.*(..))")
	public void before(){
		System.out.println("The method begins");
	}
}

Main.java测试方法:
public class Main {
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
		ArithmeticCalculator a = (ArithmeticCalculator) ctx.getBean("arithmeticCalculatorImpl");
		int result = a.add(1, 2);
		System.out.println(result);
	}
}
我测试方法执行的时候,发现ValidationAspect切面的通知先执行,因为这个切面Order注解的值小,值越小
切面的优先级越高。

重用切点表达式:
我们可以定义一个方法用来声明切入点表达式。一般的,该方法里面不需要添加其他代码。
案例代码:
LoggingAspect.java切面:
@Order(2)
@Aspect
@Component
public class LoggingAspect {
	
	@Pointcut("execution(* com.iflytek.spring.aop.ArithmeticCalculator.*(..))")
	public void declareJointPointExpression(){}     这个方法用来声明切入点表达式
	
	@Before("declareJointPointExpression()")
	public void before(){
		System.out.println("The method begins");
	}
	
	@After("declareJointPointExpression()")       引用的时候用方法名加后面的括号
	public void afterMethod(JoinPoint joinPoint){
		String methodName = joinPoint.getSignature().getName();
		List<Object> list = Arrays.asList(joinPoint.getArgs());
		System.out.println("the method name:"+methodName+"args:"+list);
	}
}

下面说下别的切面怎么引用:
ValidationAspect.java切面
@Order(1)
@Aspect
@Component
public class ValidationAspect {
	@Before("LoggingAspect.declareJointPointExpression()")       直接用切入点表达式所在类名点这个切入点表达式方法名带括号,要是这两个切面不在同一个包下,这里就要把切入点表达式所在类的包名也要带上。
	//@Before("com.iflytek.spring.aop.LoggingAspect.declareJointPointExpression()") 要是两个切面不在一个包下,需要这么引用
	public void validateArgs(JoinPoint joinPoint){
		System.out.println("validate:"+Arrays.asList(joinPoint.getArgs()));
	}
}

基于XML的配置声明切面:
除了使用AspectJ注解声明切面,Spring也支持在Bean配置文件中声明切面。
案例代码:
applicationCotext.xml配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- 这个是实现类的bean -->
	<bean id="arithmeticCalculatorImpl" class="com.iflytek.spring.xml.ArithmeticCalculatorImpl"></bean>
	<!--这个是切面的bean,里面写了很多的通知方法,比如前置通知方法 -->
	<bean id="loggingAspect" class="com.iflytek.spring.xml.LoggingAspect"></bean>
	
	<!-- 配置AOP -->
	<aop:config>
								<!--这里就是声明一个切入点表达式,表明通知要作用在哪些类的哪些方法上,后面的通知就可以直接引用这个表达式值 -->
		<aop:pointcut expression="execution(* com.iflytek.spring.aop.ArithmeticCalculator.*(..))" 
					id="pointcut"/>
		<aop:aspect ref="loggingAspect" order="2">        声明一个切面   order是切面优先级
 			<aop:before method="before" pointcut-ref="pointcut"/>    声明一个前置通知,method="before"  这个before是loggingAspect切面里的一个方法,总结切来就是我前置通知要执行loggingAspect切面里面的before方法
			<aop:after method="afterMethod" pointcut-ref="pointcut"/> 声明一个后置通知,pointcut-ref这个值去引用一个切点表达式来说明我这个通知要作用在哪些类的哪些方法上。你直接用pointcut=""也行。只不多双引号里面就要你自己写表达式了而不能引用了。
		</aop:aspect>
	</aop:config>
</beans>

Spring对JDBC的支持:
jdbcTemplate简介:
为了使JDBC更加易于使用,Spring在JDBC API上定义了一个抽象层,以此建立一个JDBC存取框架。
案例代码:
spring配置文件applicationContex.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	<context:property-placeholder location="classpath:db.properties"/>
	<!-- 配置c3p0数据源 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="user" value="${user}"></property>
		<property name="password" value="${password}"></property>
		<property name="jdbcUrl" value="${jdbcUrl}"></property>
		<property name="driverClass" value="${driverClass}"></property>
		<property name="initialPoolSize" value="${jdbc.initPoolSize}"></property>
		<property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
	</bean>
	<!-- 配置Spring的JdbcTemplate -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
</beans>

测试类:
public class SpringTest {
	
	private ApplicationContext ctx = null;
	private JdbcTemplate jdbcTemplate = null;
	{
		ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
		jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate");
	}
	
	/**
	 * 查询实体类的集合
	 */
	@Test
	public void testQueryForList(){
		String sql = "select empId,empName,emile from employee where empId > ?";
		RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<Employee>(Employee.class);
		List<Employee> list = jdbcTemplate.query(sql, rowMapper,2);
		System.out.println(list);
	}
	
	/**
	 * 从数据库中获取一条记录,然后把这条记录映射为一个对象
	 * 调用queryForObject方法,里面传入RowMapper,指定如何去映射结果集中的行,常用的实现类BeanPropertyRowMapper
	 * 注意：
	 * 1.如果数据表中字段名和属性名不一致还要指定一个别名来完成字段名和属性名的映射,如:select empId id from employee 类的属性名为id,数据表字段名为empId就该这么写
	 * 2.JdbcTemplate只是JDBC的一个小工具,不是ORM框架,不支持级联属性。
	 */
	@Test
	public void testQueryForObject(){
		String sql = "select empId,empName,emile,deptId as \"department.deptId\" from employee where empId = ?";
		RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
		Employee employee = jdbcTemplate.queryForObject(sql, rowMapper,1);
		System.out.println(employee);
	}
	
	/**
	 * 批量更新,可以是INSERT DELETE UPDATE
	 */
	@Test
	public void batchUpdate(){
		String sql = "insert into employee(empName,emile,deptId) values (?,?,?)";
		List<Object[]> batchArgs = new ArrayList<Object[]>();
		batchArgs.add(new Object[]{"zxc","123@qq.com",1});
		batchArgs.add(new Object[]{"cvb","456@qq.com",2});
		jdbcTemplate.batchUpdate(sql, batchArgs);
	}
	
	/**
	 * 更新记录
	 */
	@Test 
	public void update(){
		String sql = "update employee e set e.empName = ? where e.empId = ?";
		jdbcTemplate.update(sql, "bb",2);
	}
}

Spring中事务管理:
事务是企业级应用程序开发中必不可少的技术,用来确保数据的完整性和一致性。事务是一系列的动作,
这些动作要么全部完成,要么全部不起作用。

Spring支持编程式事务管理,也支持声明式事务管理。

编程式事务管理:将事务管理代码嵌入到业务方法中来控制事务提交和回滚。

声明式事务管理:将事务管理代码从业务方法中分离出来,以声明的方式来实现事务管理。
声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建
或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是
不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中
做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。

说一下spring声明式事务的配置:
首先说基于注解的方式:
spring的配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	<context:component-scan base-package="com.iflytek.spring"></context:component-scan>
	<context:property-placeholder location="classpath:db.properties"/>
	<!-- 配置c3p0数据源 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="user" value="${user}"></property>
		<property name="password" value="${password}"></property>
		<property name="jdbcUrl" value="${jdbcUrl}"></property>
		<property name="driverClass" value="${driverClass}"></property>
		<property name="initialPoolSize" value="${jdbc.initPoolSize}"></property>
		<property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
	</bean>
	<!-- 配置Spring的JdbcTemplate -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	<!-- 配置事务管理器 -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 使@Transactional注解生效,即启用注解 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>
</beans>

BookShopServiceImpl.java:
@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {
	
	@Autowired
	private BookShopDao bookShopDao;
	
	@Transactional
	@Override
	public void purchase(String userName, String isbn) {
		//获取书的单价
		int price = bookShopDao.findBookPriceByIsbn(isbn);
		//更新书的库存
		bookShopDao.updateBookStock(isbn);
		//更新用户余额
		bookShopDao.updateUserAccount(userName, price);
	}
}
我买本书后希望账户余额和库存同时减少,要么一起成功要么一起失败。我就可以在这个方法上面加个事务。
具体需要现在spring配置文件里面先配置一个事务管理器,然后配置一个<tx:annotation-driven/>这个是为了
让方法上的@Transactional注解生效的一个驱动。最后在你需要加事务的方法上标一个@Transactional注解就好了
现在加了事务后假设上面的方法我余额不够买一本书的那么库存不会减少余额也不会减少。要是不加事务
就会库存减了,但是因为余额不足报错导致余额并没有减少。这样就有问题了。

简单说一下对<tx:annotation-driven />的理解:
首先,<tx:annotation-driven/>  会有一个属性来指定使用哪个事务管理器,如:<tx:annotation-driven transaction-manager="transactionManager" />
然后事务管理器 transactionManager 会引用 dataSource,dataSouce 肯定就是直接对数据库的了。
这样逐层引用下去，所以我们使用@Transactionl 注解可以控制事务就通俗易懂了。

事务的传播行为:
当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。例如:方法可能继续在现有的事务中运行,
也可能开启一个新事务,并在自己的事务中运行。

事务的传播行为可以由传播属性指定。

传播属性:
REQUIRED:如果有事务在运行,当前的方法就在这个事务内运行。否则就启动一个新的事务,并在自己的事务
内运行。
REQUIRED_NEW:当前的方法必须启动新的事务,并在它自己的事务内运行。如果有事务正在运行,将它挂起。

案例代码:
BookShopServiceImpl.java:
@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {
	@Autowired
	private BookShopDao bookShopDao;
	
	@Transactional(propagation=Propagation.REQUIRED)  ①  事务的传播行为指定为REQUIRED(默认也是REQUIRED)
	@Override
	public void purchase(String userName, String isbn) {
		//获取书的单价
		int price = bookShopDao.findBookPriceByIsbn(isbn);
		//更新书的库存
		bookShopDao.updateBookStock(isbn);
		//更新用户余额
		bookShopDao.updateUserAccount(userName, price);
	}
}

CashierImpl.java:
public class CashierImpl implements Cashier {
	
	@Autowired
	private BookShopService bookShopService;
	
	@Transactional
	@Override
	public void checkout(String name, List<String> isbns) {    这个方法主要用来买多本书
		for(String isbn :isbns){
			bookShopService.purchase(name, isbn);
		}
	}
}
现在我这个checkout方法开了一个事务,然后在方法里面调的purchase方法里面也开了一个事务。那么我
purchase方法到底是用自己的事务还是用checkout方法的事务呢？这就牵扯到事务的传播行为。默认是REQUIRED
就是我checkout方法有事务在运行,那么我purchase方法就用checkout里面的事务。
现在假设我买两本书。但是余额只够买一本书的。要是执行了上面的checkout方法,请问第一本书买成功没？
(第二本书肯定没买成功嘛,因为钱只够买一本)答案是都没买成功。数据库里面的库存和余额都没减少。
因为用的是checkout方法里面的事务,都买成功才成功。

现在假如我把①处的代码改成@Transactional(propagation=Propagation.REQUIRES_NEW)那么请问上面的
情况我第一本书买成功了没？
答案是成功了。因为这个REQUIRES_NEW,  purchase方法用的是自己的事务。因为checkout方法里面也有事务,
所以先将这个事务挂起,因为钱是够买一本书的,所以买第一本的时候我用的是purchase自己的事务,所以成功了
就是真的成功了。但是买第二本的时候失败了,回滚到purchase自己的事务中,所以库存只减了一本余额也
只少了一本的余额。

事务的隔离级别:
为什么会有事务隔离级别这回事呢？
因为在事务并发的时候,会发生脏读、不可重复读、幻读等问题。即:
当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时,可能会出现意外问题。
并发事务所导致的问题:
1、脏读：对于两个事务T1、T2,T1读取了已经被T2更新但还没有被提交的字段。之后,若T2回滚,T1读取的内容
就是临时且无效的。
2、不可重复读:对于两个事务T1、T2,T1读取了一个字段,然后T2更新了该字段。之后,T1再次读取同一个字段
值就不同了。
3、对于两个事务T1、T2,T1从一个表中读取一个字段,然后T2在该表中插入一些新的行。之后,如果T1再次读取
同一个表,就会多出几行。

案例代码:
BookShopServiceImpl.java:
@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {
	
	@Autowired
	private BookShopDao bookShopDao;
	
	@Transactional(propagation=Propagation.REQUIRES_NEW
														,isolation=Isolation.READ_COMMITTED,timeout=1,readOnly=false)
	@Override
	public void purchase(String userName, String isbn) {
		//获取书的单价
		int price = bookShopDao.findBookPriceByIsbn(isbn);
		//更新书的库存
		bookShopDao.updateBookStock(isbn);
		//更新用户余额
		bookShopDao.updateUserAccount(userName, price);
	}
}
使用isolation来指定事务的隔离级别,最常用的是READ_COMMITTED
使用readonly指定事务是否为只读,表示这个事务只读取数据但不更新数据,若真的是一个只读取数据库值的方法,应该设置readonly=true
使用timeout指定强制回滚之前事务可以占用的时间。
默认情况下spring的声明式事务对所有运行时异常进行回滚。

推荐一篇博客地址:http://www.cnblogs.com/fjdingsd/p/5273008.html

事务的超时和只读属性:
由于事务可以在行和表上获得锁,因此长事务会占用资源,并对整体性能产生影响。
超时事务属性:事务在强制回滚之前可以保持多久,这样可以防止长期运行的事务占用资源。
只读事务属性:表示这个事务只读取数据但不更新数据,这样可以帮助数据库引擎优化事务。

使用xml的方式配置事务:
spring的配置文件:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	<context:component-scan base-package="com.iflytek.spring"></context:component-scan>
	<context:property-placeholder location="classpath:db.properties"/>
	<!-- 配置c3p0数据源 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="user" value="${user}"></property>
		<property name="password" value="${password}"></property>
		<property name="jdbcUrl" value="${jdbcUrl}"></property>
		<property name="driverClass" value="${driverClass}"></property>
		<property name="initialPoolSize" value="${jdbc.initPoolSize}"></property>
		<property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
	</bean>
	<!-- 配置Spring的JdbcTemplate -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<bean id="bookShopDao" class="com.iflytek.spring.tx.xml.BookShopDaoImpl">
		<property name="jdbcTemplate" ref="jdbcTemplate"></property>
	</bean>
	
	<bean id="bookShopServiceImpl" class="com.iflytek.spring.tx.xml.BookShopServiceImpl">
		<property name="bookShopDao" ref="bookShopDao"></property>
	</bean>
	
	<bean id="cashierImpl" class="com.iflytek.spring.tx.xml.CashierImpl">
		<property name="bookShopService" ref="bookShopServiceImpl"></property>
	</bean>
	
	<!-- 1、配置事务管理器 -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<!-- 2、配置事务属性 -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="*"/>
			<!-- 根据方法名指定事务的属性,默认情况下这个propagation都为REQUIRED -->
			<tx:method name="purchase" propagation="REQUIRES_NEW"/>
			<!-- 一般get开头的方法都是查询数据,不更新数据,这样我们设置 read-only="true"可以帮助数据库引擎优化事务-->
			<tx:method name="get*" read-only="true"/>
			<tx:method name="find*" read-only="true"/>
		</tx:attributes>
	</tx:advice>
	
	<!-- 3、配置事务切点 -->
	<aop:config>
		<aop:pointcut expression="execution(* com.iflytek.spring.tx.xml.BookShopService.*(..))" 
					id="txpointCut"/>
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txpointCut"/>
	</aop:config>
</beans>






































































































































































































































































































































































































































































